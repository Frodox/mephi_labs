#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\begin_preamble

\usepackage{cmap}	  % support of searching russian words in PDF
\usepackage[T2C]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{enumitem}

\usepackage{indentfirst}	%красная строка
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding cp1251
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 14
\spacing single
\use_hyperref true
\pdf_title "132"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle plain
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Компиляторы и теория компиляции
\end_layout

\begin_layout Author
Ибрагимов Арсен Мирзахмедович
\end_layout

\begin_layout Date
feb 2014 --- may 2014
\end_layout

\begin_layout Right Address
k8-361, НИЯУ 
\begin_inset Quotes fld
\end_inset

МИФИ
\begin_inset Quotes frd
\end_inset


\begin_inset Newline newline
\end_inset

ver.
 0.2
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Введение
\end_layout

\begin_layout Description
Язык программирования -- формальный способ описания вычислений для людей
 и машин.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Каждый раз повышая абстракность, мы привносим ограничения.
 При переходе к процедурному программированию, уже не можем 
\begin_inset Quotes fld
\end_inset

прыгать
\begin_inset Quotes frd
\end_inset

 в любое место программы.
 От процедурного к ООП -- надо думать в терминах классов.
 Современные языки стараются уменьшить вероятность ошибок, привнося больше
 абстракции.
 Ещё более высокие
\begin_inset space ~
\end_inset

(SQL; сиквел), делаются для конкретных задач, ограничивает ещё сильнее
\begin_inset space ~
\end_inset

(нет циклов, например).
 Каждое привнесение абстракции усложняет/затрудняет его преобразование в
 машинный код
\begin_inset space ~
\end_inset

(код платформы).
 Чем высокоуровневее язык, тем сложнее пеперести код в машинный.
 Идеально оптимизированный код -- вообще говоря, NP\SpecialChar \nobreakdash-
полная задача.
\end_layout

\begin_layout Standard
Рассмотри 2 способа работы:
\end_layout

\begin_layout Enumerate
|src| → |компилятор| → |машинный код| → исполняем
\end_layout

\begin_deeper
\begin_layout Itemize
+: быстрая работа
\end_layout

\begin_layout Itemize
--: код под определённую платформу
\end_layout

\end_deeper
\begin_layout Enumerate
|src| → |интерпретатор| → исполняем каждую инструкцию
\end_layout

\begin_deeper
\begin_layout Itemize
+: лучшее отслеживание ошибок (в Runtime)
\end_layout

\begin_layout Itemize
+: возможность Runtime оптимизаций (Jit)
\end_layout

\begin_layout Itemize
--: медленно работает
\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Standard
Так же, Jit компилятор может на ходу менять то, что ранее было скомпилировано
 (подстраиваться под работу системы, компилируя те куски которые чаще всего
 используются).
\end_layout

\begin_layout Description
Компилятор
\begin_inset space ~
\end_inset

(транслятор) --- некоторое приложение, переводящее программу написанную
 на некотором языке, называемом 
\emph on
исходным,
\emph default
 в 
\emph on
эквивалентную
\emph default

\begin_inset space ~
\end_inset

(должна делать то же самое; эмулировать side-эффекты) программу на другом
 языке, называемым 
\emph on
целевым
\emph default
.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Тоже самое! Т.е.
 имея 2 программы, с двумя входами и двумя выходами, одинаковвыми, мы никогда
 их не отличим.
 Т.е.
 подразумеваются именно side-эффекты
\begin_inset space ~
\end_inset

(хорошо бы, чтобы они были реализованы быстро и оптимально).
\end_layout

\begin_layout Subsection
Компиляция
\end_layout

\begin_layout Description
Компиляция -- процесс перевода из исходного языка в целевой.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Состоит из нескольких частей:
\end_layout

\begin_layout Enumerate
Анализ
\end_layout

\begin_layout Enumerate
Синтез
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Itemize
исходный код -- | анализ | --> промежуточное представление -- |
\begin_inset space ~
\end_inset

синтез
\begin_inset space ~
\end_inset

| --> целевой код
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Таким образом задача перевода из одних языков в другие сводится из 
\family typewriter
nxm
\family default
 к 
\family typewriter
n+m
\family default
.
 Важно хорошо выбрать промежуточный код
\begin_inset space ~
\end_inset

(пример -- Gnu
\begin_inset space ~
\end_inset

Compiler
\begin_inset space ~
\end_inset

Collection).
\end_layout

\begin_layout Subsubsection
Анализ
\end_layout

\begin_layout Standard

\series bold
Принцип работы
\end_layout

\begin_layout Standard
(Исходный язык) --> лексический анализатор --> 
\begin_inset Newline newline
\end_inset

(последовательность токенов) --> синтаксический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтаксическре дерево) --> семантический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтактическое дерево
\begin_inset space ~
\end_inset

v2
\begin_inset space ~
\end_inset

[промежуточное состояние])\SpecialChar \ldots{}
 --> генератор промежуточного кода
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

example:
\end_layout

\begin_layout Plain Layout

newValue = oldValue*3 + module
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Лексический анализатор
\end_layout

\begin_layout Standard
Лексический анализатор разбивает код на 
\emph on
лексемы
\emph default
 -- связанные/целостные куски.
 Из примера выше: 
\family typewriter
newValue, =, oldValue, *, 3, +, module.
\family default
Также он создаёт последовательность токенов
\begin_inset space ~
\end_inset

(и различает их по типу).
\end_layout

\begin_layout Standard
Есть так называемая 
\series bold
Таблица
\begin_inset space ~
\end_inset

символов
\series default
, проходит через все фазы компиляции.
 При создании компилятра даём множество всех лексем, разделённых на некоторые
 группы -- множества цифр, идентификтаоров, целых чисел и т.
\begin_inset space \thinspace{}
\end_inset

п.
 Правила определения группы не должны быть неоднозначны
\begin_inset space ~
\end_inset

(поэтому, например, никогда идентификаторы не начинаются с цифры).
 Тип правила, которому соответствует определённый кусок, определяет тип
 токена
\begin_inset space ~
\end_inset

(идентификатор, \SpecialChar \ldots{}
).
 Анализатор проходит слева направо, и создаёт новую строку с токенами.
 Например, взял строчку из примера, идёт, раз -- идентификатор, и идёт\SpecialChar \ldots{}
 пока
 не встретит нечто что не идентификатор.
 И пишет создаёт токен: 
\family typewriter
<id_1>.

\family default
 А в таблицу символов добавлет аля 
\family typewriter
id_1 -> newValue, float,\SpecialChar \ldots{}
 
\family default
В таблице символов в итоге содержится всё, что относится к переменным и
 идентификаторами
\begin_inset space ~
\end_inset

(заполняется не только лексическим анализатором).
 И так далее.
 Затем получаем последовательность токенов: 
\family typewriter
<id_1><=><id_2><*><3><+><id_3>.
\end_layout

\begin_layout Standard

\series bold
Синтаксический анализатор
\end_layout

\begin_layout Standard
Далее отправляем последовательность токенов Синтаксическому Анализатору,
 который должен построит дерево операций
\begin_inset space ~
\end_inset

(узлы -- операции, листья -- переменные/значения).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-1.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево операций, постоенное синтаксическим анализатором
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Задача СА -- используя последовательность токенов, построит вот такое дерево.
 К Таблице Символов он обычно не обращается.
 На самом деле, дерево выглядит как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

.
 СА выцепляет заранее заданные структуры языка, преобразует их в кусочки
 дерева и затем объединяем в одно общее дерево.
 СА проверяет корректность семантики выражений
\begin_inset space ~
\end_inset

(например, нельзя прибавить строку к числу и т.
\begin_inset space \thinspace{}
\end_inset

п.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-2.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Настоящее дерево операций :D
\begin_inset CommandInset label
LatexCommand label
name "fig:Настоящее-дерево-операций"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Для построения используются определённые алгоритмы, аля BNF и т.п.
 Если СА не знает что делать, он выдаёт ошибку.
\end_layout

\begin_layout Standard

\series bold
Семантический анализатор
\end_layout

\begin_layout Standard
Но в Сем.
 Анализатор можно заложить логику, которая будет такие ошибки обходить.
 Например
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

float a = 3;        // not correct
\end_layout

\begin_layout Plain Layout

float a = (float)3; // correct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float a = 3; => float a = (float)3;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Но зачем заставлять программиста выполнять то, что может сделать СА? Поэтому,
 после СА дерево будет выглядеть как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

 + операция 
\family typewriter
<to_float> 
\family default
перед узлом 
\family typewriter
3
\family default
.
\end_layout

\begin_layout Standard
Теперь можно получить промежуточный код.
 
\end_layout

\begin_layout Standard

\series bold
Пример
\series default
.
 Пусть хотим посчитать 
\family typewriter
b = b + 3
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

# asm example
\end_layout

\begin_layout Plain Layout

# cmd   where what
\end_layout

\begin_layout Plain Layout

MOV 	Ax    %b
\end_layout

\begin_layout Plain Layout

MOV 	Bx    3
\end_layout

\begin_layout Plain Layout

ADD 	Ax    Bx
\end_layout

\begin_layout Plain Layout

MOV 	%b    Ax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Обычно промежуточное предстваление -- какой-либо трёхадрессный код
\begin_inset space ~
\end_inset

(что то вроде ассемблера, но высокоуровневее), а может быть и дерево.
\end_layout

\begin_layout Standard
Для примера выше:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

TOFLOAT <a> <3>
\end_layout

\begin_layout Plain Layout

MUL <b> <id_2> <b>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Трёхадрессный код легко оптимизируем
\begin_inset space ~
\end_inset

(в примере выше --- операция 
\family typewriter
TOFLOAT
\family default
 -- избыточна, можно сразу написать 
\family typewriter
3.0 .
 
\family default
Это называет 
\emph on
платформо-независимая оптимизация
\emph default
.)
\end_layout

\begin_layout Subsubsection
Синтез
\end_layout

\begin_layout Description
Синтез --- получение из промежуточного представления
\begin_inset space ~
\end_inset

(кода) конечной целевой программы.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Enumerate
(Промежуточный код/представление) --> 
\end_layout

\begin_layout Enumerate
машинно-независимые оптимизации
\begin_inset Newline newline
\end_inset

(с заданным критерием; по памяти, по скорости, по регистрам, по загружаемым
 в Java-машину классам, \SpecialChar \ldots{}

\begin_inset Note Note
status open

\begin_layout Plain Layout
switch при оптимизации преобразуется в дерево, чтобы можно было делать бинарный
 поиск,
\end_layout

\begin_layout Plain Layout
если в if некоторая ветвь выполняется в 80% случаев, то имеет смысл сдеать
 её первой
\end_layout

\end_inset

) --> 
\end_layout

\begin_layout Enumerate
(более оптимальный по какому-либо критерию промежуточный код) -->
\end_layout

\begin_layout Enumerate
генерация/преобразования целевого кода
\begin_inset space ~
\end_inset

(i.e.
 для платформы 
\family typewriter
x86
\family default
)--> 
\end_layout

\begin_layout Enumerate
(целевой код) --> 
\end_layout

\begin_layout Enumerate
машинно-зависимые оптимизации
\begin_inset Newline newline
\end_inset

(на основе архитектуры процессора) --> 
\end_layout

\begin_layout Enumerate
(
\begin_inset Quotes fld
\end_inset

оптимальный
\begin_inset Quotes frd
\end_inset

 целевой код)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Все эти фазы активно использую таблицу символов.
\end_layout

\begin_layout Standard
Имеются генераторы синтаксический анализаторов, лексических анализаторов,
 кода.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 2 // 24-фев-2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Основные понятия языков программирования
\end_layout

\begin_layout Standard

\series bold
Область видимости переменной 
\series default
(почитай про них самостоятельно в интернете):
\end_layout

\begin_layout Itemize
статические
\end_layout

\begin_layout Itemize
динамические
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

       среда               	состояние
\end_layout

\begin_layout Plain Layout

  |--------------v	|------------------v
\end_layout

\begin_layout Plain Layout

имена		ячейки памяти		значения
\end_layout

\begin_layout Plain Layout

  x		 ячейка №376		 яблоко
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Есть имя переменной.
 Оно что то значит.
 привязано к некой ячейке памяти.
 с ячейкой памяти связано определённое значение.
 Ячейка памяти определяется или как само значение или ссылка (на другое
 значение).
\end_layout

\begin_layout Standard
Так же важно блочная структура.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ //1				
\end_layout

\begin_layout Plain Layout

	{//2	{//3 ...} }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	{//4  
\end_layout

\begin_layout Plain Layout

		{//5 ...
 <we are here>}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Мы в любой момент находимся в определённом блоке, и нашу позицию можно описать
 линейной последовательностью.
\end_layout

\begin_layout Standard
Обычно используют связанные списки (при компиляции).
 Рис.
\end_layout

\begin_layout Standard
При поиске определённой переменной, идём в обратную сторону (от самого нижележащ
его блока -- вверх), как найдём переменную с таким-то именем, её и используем.
\end_layout

\begin_layout Standard
Передача переменной:
\end_layout

\begin_layout Itemize
По имени
\end_layout

\begin_layout Itemize
По ссылке
\end_layout

\begin_layout Itemize
По Значению \SpecialChar \ldots{}

\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsection
Построение дерева разбора и контекстно свободные грамматики
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

do {
\end_layout

\begin_layout Plain Layout

	int i=0;
\end_layout

\begin_layout Plain Layout

	for (int j=0; j<10; j++) i--;
\end_layout

\begin_layout Plain Layout

} while (true)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Дерево не может описывать динамику приложения.
 Оно может лишь описывать некую логическую структуру.
 Осмысленную семантику мы в это не вкладываем.
 То что строки в коде выполняются последовательно, имеется ввиду, что между
 строками есть некий 
\begin_inset Quotes fld
\end_inset

оператор порядка
\begin_inset Quotes frd
\end_inset

.
 С точки зрения дерева -- оператора порядка нет никакого, можем лишь ввести
 искусственно.
 В языке часто не всё отражается в синтаксисе, а отражается в неких дополнительн
ых соглашениях.
 
\family typewriter
{} -- 
\family default
тоже оператор (блочный) специально введённый, т.к.
 сам 
\family typewriter
do...while
\family default
 работает лишь с одним оператором.
 Построим начало дерева разбора:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Контекстно свободные грамматики
\end_layout

\begin_layout Plain Layout

do < оператор > while <условие>
\end_layout

\begin_layout Plain Layout

if (< условие >) <выражение>
\end_layout

\begin_layout Plain Layout

if (<условие>) <выражение> else <выражение>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
За счёт таких различных подстановок у нас есть возможность описать многие
 языки программирования.
 Это -- лишь синтаксис.
 С точки зрения семантики это ничего не значит (смысла не вкладывается).
\end_layout

\begin_layout Subsection
Контекстно-свободные грамматики (Backus-Naur Form)
\end_layout

\begin_layout Description
Контекстно-свободная
\begin_inset space ~
\end_inset

грамматика --- совокупность четырёх множеств:
\end_layout

\begin_layout Itemize
множество терминальных символов (терминалов
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
языки различаются по тому, какие терминальные символы можно использовать
\end_layout

\end_inset

) 
\family typewriter
T
\family default

\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if ( } , else while 5
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
множество не терминальных символов (не терминалов) 
\family typewriter
N
\family default

\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<условие>, <выражение>, ...
\end_layout

\end_inset

Что-то, что можно заменить каким-либо образом на что-то.
 Смотрим по определению условия/выражения и заменяем.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (<усл>) <выражение> => if (<усл1> && <усл2>) <выражение>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

а определение:
\end_layout

\begin_layout Plain Layout

<условие> := <усл> && <усл>
\end_layout

\begin_layout Plain Layout

		   ||
\end_layout

\begin_layout Plain Layout

	  	    ~
\end_layout

\end_inset

 и т.д.
 В итоге, желательно за конечное число подстановок, получаем выражение лишь
 с 
\emph on
терминальными
\emph default
 символами.
\end_layout

\begin_layout Itemize
множество правил вывода 
\family typewriter
P:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $n\in N$
\end_inset

, 
\begin_inset Formula $n:=a_{0}a_{1}a_{2}...a_{k}$
\end_inset

, 
\family default
где 
\family typewriter

\begin_inset Formula $a_{i}\in N\cup T$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $:=$
\end_inset

 
\family default
---
\family typewriter
 
\family default
можно представить как
\end_layout

\begin_layout Itemize
множество из одного элемента -- начальный символ 
\begin_inset Formula $s\in N$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Когда произвождим разбор грамматики, то сначала было 
\begin_inset Formula $s$
\end_inset

.
 
\end_layout

\begin_layout Standard
Затем: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->a+a->a+a-a->3+a-a->3+1-a->3+1-1
\end_layout

\begin_layout Plain Layout

а хотим посчитать
\end_layout

\begin_layout Plain Layout

3+1-7,
\end_layout

\begin_layout Plain Layout

с грамматикой (очень плохой, т.к.
 не однозначной):
\end_layout

\begin_layout Plain Layout

s:=a+a
\end_layout

\begin_layout Plain Layout

s:=a-a
\end_layout

\begin_layout Plain Layout

a:=a+a
\end_layout

\begin_layout Plain Layout

a:=a-a
\end_layout

\begin_layout Plain Layout

a:=0|..|9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Поэтому написание грамматики -- очень сложная задача.
 Точнее -- создание 
\emph on
правильной 
\emph default
грамматики.
 Поэтому обычно используют уже готовые (L|R).
\end_layout

\begin_layout Standard
Напишем более простую грамматику, которая позволит такие предложения разбирать
 
\family typewriter
(3+7)*(3)+3+7
\end_layout

\begin_layout Itemize
Терминальные символы: 
\family typewriter
0..9, (, ), +, -, *, /
\end_layout

\begin_layout Itemize
Не терминальные: 
\family typewriter
s
\end_layout

\begin_layout Itemize
Начальный: 
\family typewriter
s
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
напишем грамматику, которая может генерировать все возможные арифметичесие
 выражения:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# d -- digital
\end_layout

\begin_layout Plain Layout

1, 3+7, (3+7)
\end_layout

\begin_layout Plain Layout

2, 3-5, (1)
\end_layout

\begin_layout Plain Layout

0, 3/7
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s->d|s+d|s-d|s*d|s/d|(s)
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# автоматически: 
\end_layout

\begin_layout Plain Layout

(s)->(d)->(1)
\end_layout

\begin_layout Plain Layout

s+d->(s)+d->(s+d)->(d+d)+d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Но!
\end_layout

\begin_layout Plain Layout

3+(7*3) # мы ещё не можем.
 Проблемка..
 как минимально улучшить?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# введём ещё переменную:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s->d|s+e|s-e|s*e|s/e|e
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

e->(e)|d|s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Вся эта грамматика очень очень плохая, т.к.
 при построении дерева не учитывается порядок операций.
\end_layout

\begin_layout Standard
Пример:
\end_layout

\begin_layout Standard

\family typewriter
3+7*4
\end_layout

\begin_layout Standard
рис 3
\end_layout

\begin_layout Standard
получим в итоге 
\family typewriter
(3+7)*4
\end_layout

\begin_layout Standard
Приоритет и ассоциативность операций.
\end_layout

\begin_layout Standard
Если есть что-то, окружённое двумя операторами, то 2 случая -- операторы
 одинаковые (тогда вступаем в силу правило ассоциативности -- левые или
 правые) или разные (тогда в ступает в действие приоритет операций).
\end_layout

\begin_layout Standard
Т.е.
 
\family typewriter
(((3-4)-7)-9),
\family default
 и
\family typewriter
 (a=(b=(c=(4))))
\end_layout

\begin_layout Standard
Как учитывать ассоциативность короче? Введём ещё терминальные символы, для
 каждой из ассоциативностей:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Боле мене адекватная грамматика
\begin_inset CommandInset label
LatexCommand label
name "fig:Боле-мене-адекватная"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Т.е.
 приём какой - самые приоритетные операции должны выполнятся 
\emph on
внизу
\emph default
 дерева.
 А благодаря тому, что 
\family typewriter
k->(e), 
\family default
мы можем строить подвыражения с подобными приоритетами.
 Грамматика выше -- 
\emph on
право-рекурсивная.

\emph default
 Т.е.
 каждый раз заменяется правое выражение.
\end_layout

\begin_layout Standard
Самый плохой авариант, из-за неоднозначности и отсутствия приоритетов:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->s+s|s-s|s*s|s/s|0|1..9|(s)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Неоднозначная грамматика -- если для одного выражения возможно построение
 2х различных деревьев.
 
\series bold
Пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

3+5*4
\end_layout

\begin_layout Plain Layout

s->s+s->s+s*s->...
\end_layout

\begin_layout Plain Layout

s->s*s->s+s*s->...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Такие грамматики затрудняются разбор, вносят неоднозначности.
 при построении грамматик для ЯП -- их стараются избегать.
\end_layout

\begin_layout Standard
Пример настоящего дерева разбора (с грамматикой 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

): 
\family typewriter
3+(5*7)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
вставь сююда рис 4
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора выражения на примере грамматики 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Грамматика совсем правильная, поэтому грамматика не столь простая\SpecialChar \ldots{}

\end_layout

\begin_layout Standard

\series bold
Пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Что будет производить код:
\end_layout

\begin_layout Plain Layout

s->+ss
\end_layout

\begin_layout Plain Layout

s->-ss
\end_layout

\begin_layout Plain Layout

s->1
\end_layout

\begin_layout Plain Layout

?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Пример 2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

S->aSbS
\end_layout

\begin_layout Plain Layout

s->bSaS
\end_layout

\begin_layout Plain Layout

S->E
\end_layout

\begin_layout Plain Layout

# E (эпсилон) -- пустота, обозначение пустоты
\end_layout

\begin_layout Plain Layout

резуьтат: строка состоящая из произвольного кол-ва ab в любых комбинациях,
 при этом их число равно
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Пример 3
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

S->(S)|SS|E
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# result
\end_layout

\begin_layout Plain Layout

грамматика генерирует все правильные расстановки скобочек
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Task
\series default
: 
\end_layout

\begin_layout Enumerate
Составить грамматику, генерирующую все возможные бинарные числа, делящиеся
 на 3
\end_layout

\begin_layout Enumerate
Составить все возможные идентификаторы Java.
\end_layout

\begin_layout Enumerate
Добавить в грамматику
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

 унарный плюс и унарный минус.
\end_layout

\begin_layout Enumerate
Создать грамматику, позволяющую определять переменные типов 
\family typewriter
int, double 
\family default
и инициализировать их цифрами.
\begin_inset Newline newline
\end_inset

Т.е.
 чтобы можно было делать нечто вроде:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int a,b,c=3;
\end_layout

\begin_layout Plain Layout

int z=3, k=4;
\end_layout

\begin_layout Plain Layout

# на самом деле, z=0 сюда тоже можно легко добавить
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "dragon-book"

\end_inset

А.
 Ахо., Ульман 
\begin_inset Quotes fld
\end_inset

Компиляторы(книга дракона)
\begin_inset Quotes frd
\end_inset

 // хватит сполна
\end_layout

\end_body
\end_document
