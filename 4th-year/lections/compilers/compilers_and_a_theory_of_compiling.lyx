#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\begin_preamble

\usepackage{cmap}	  % support of searching russian words in PDF
\usepackage[T2C]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{enumitem}

\usepackage{indentfirst}	%красная строка
\sloppy
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding cp1251
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 14
\spacing single
\use_hyperref true
\pdf_title "Компиляторы"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 1cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle plain
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Компиляторы и теория компиляции
\end_layout

\begin_layout Author
Ибрагимов Арсен Мирзахмедович
\end_layout

\begin_layout Date
feb 2014 --- may 2014
\end_layout

\begin_layout Right Address
k8-361, НИЯУ 
\begin_inset Quotes fld
\end_inset

МИФИ
\begin_inset Quotes frd
\end_inset


\begin_inset Newline newline
\end_inset

ver.
 0.9.1
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\emph on
Литература:
\emph default
 А.
 Ахо., Ульман 
\begin_inset Quotes fld
\end_inset

Компиляторы(книга дракона)
\begin_inset Quotes frd
\end_inset

 // хватит сполна
\end_layout

\begin_layout Section*
От Автора
\end_layout

\begin_layout Standard
Лекции предоставляются по принципу 
\begin_inset Quotes fld
\end_inset

AS IS
\begin_inset Quotes frd
\end_inset

.
 Автор не несёт ответственности за возможный материальный ущерб, незачёты
 или отчисления из института, вызванные использованием данных материалов.
\end_layout

\begin_layout Standard
Исправления, пожелания, отзывы принимаются:
\end_layout

\begin_layout Itemize
лично автором;
\end_layout

\begin_layout Itemize
на почту: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
target "lec-bugs@bitthinker.com"
type "mailto:"

\end_inset

 ;
\end_layout

\begin_layout Itemize
на страничке проекта: 
\family typewriter

\begin_inset CommandInset href
LatexCommand href
name "https://github.com/Jecomire/mephi_labs"
target "https://github.com/Jecomire/mephi_labs/tree/master/4th-year/lections/compilers"

\end_inset


\family default
 ;
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Введение
\end_layout

\begin_layout Description
Язык
\begin_inset space ~
\end_inset

программирования --- формальный способ описания вычислений для людей и машин.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Каждый раз повышая абстрактность, мы привносим ограничения.
 При переходе к процедурному программированию, уже не можем 
\begin_inset Quotes fld
\end_inset

прыгать
\begin_inset Quotes frd
\end_inset

 в любое место программы.
 От процедурного к ООП -- надо думать в терминах классов.
 Современные языки стараются уменьшить вероятность ошибок, привнося больше
 абстракции.
 Ещё более высокие
\begin_inset space ~
\end_inset

(SQL; сиквел), делаются для конкретных задач, ограничивает ещё сильнее
\begin_inset space ~
\end_inset

(нет циклов, например).
 Каждое привнесение абстракции усложняет/затрудняет его преобразование в
 машинный код
\begin_inset space ~
\end_inset

(код платформы).
 Чем высокоуровневее язык, тем сложнее пеперести код в машинный.
 Идеально оптимизированный код -- вообще говоря, NP\SpecialChar \nobreakdash-
полная задача.
\end_layout

\begin_layout Standard
Рассмотри 2 способа работы:
\end_layout

\begin_layout Enumerate
|src| → |компилятор| → |машинный код| → исполняем
\end_layout

\begin_deeper
\begin_layout Itemize
+: быстрая работа
\end_layout

\begin_layout Itemize
--: код под определённую платформу
\end_layout

\end_deeper
\begin_layout Enumerate
|src| → |интерпретатор| → исполняем каждую инструкцию
\end_layout

\begin_deeper
\begin_layout Itemize
+: лучшее отслеживание ошибок (в Runtime)
\end_layout

\begin_layout Itemize
+: возможность Runtime оптимизаций (Jit)
\end_layout

\begin_layout Itemize
--: медленно работает
\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Standard
Так же, 
\family typewriter
Jit
\family default
 компилятор может на ходу менять то, что ранее было скомпилировано (подстраивать
ся под работу системы, компилируя те куски которые чаще всего используются).
\end_layout

\begin_layout Description
Компилятор
\begin_inset space ~
\end_inset

(транслятор) --- некоторое приложение, переводящее программу написанную
 на некотором языке, называемом 
\emph on
исходным,
\emph default
 в 
\emph on
эквивалентную
\emph default

\begin_inset space ~
\end_inset

(должна делать то же самое; эмулировать side-эффекты) программу на другом
 языке, называемым 
\emph on
целевым
\emph default
.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Тоже самое! Т.е.
 имея 2 программы, с двумя входами и двумя выходами, одинаковыми, мы никогда
 их не отличим.
 Т.е.
 подразумеваются именно side-эффекты
\begin_inset space ~
\end_inset

(хорошо бы, чтобы они были реализованы быстро и оптимально).
\end_layout

\begin_layout Subsection
Компиляция
\end_layout

\begin_layout Description
Компиляция -- процесс перевода из исходного языка в целевой.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Состоит из нескольких частей:
\end_layout

\begin_layout Enumerate
Анализ
\end_layout

\begin_layout Enumerate
Синтез
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Itemize
исходный код -- | анализ | --> промежуточное представление -- |
\begin_inset space ~
\end_inset

синтез
\begin_inset space ~
\end_inset

| --> целевой код
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Таким образом задача перевода из одних языков в другие сводится из 
\family typewriter
nxm
\family default
 к 
\family typewriter
n+m
\family default
.
 Важно хорошо выбрать промежуточный код
\begin_inset space ~
\end_inset

(пример -- 
\family typewriter
Gnu
\begin_inset space ~
\end_inset

Compiler
\begin_inset space ~
\end_inset

Collection
\family default
).
\end_layout

\begin_layout Subsubsection
Анализ
\end_layout

\begin_layout Standard

\series bold
Принцип работы
\end_layout

\begin_layout Standard
(Исходный язык) --> лексический анализатор --> 
\begin_inset Newline newline
\end_inset

(последовательность токенов) --> синтаксический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтаксическое дерево) --> семантический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтаксическое дерево
\begin_inset space ~
\end_inset

v2
\begin_inset space ~
\end_inset

[промежуточное состояние])\SpecialChar \ldots{}
 --> генератор промежуточного кода
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

example:
\end_layout

\begin_layout Plain Layout

newValue = oldValue*3 + module
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Лексический анализатор
\end_layout

\begin_layout Standard
Лексический анализатор разбивает код на 
\emph on
лексемы
\emph default
 -- связанные/целостные куски.
 Из примера выше: 
\family typewriter
newValue, =, oldValue, *, 3, +, module.
\family default
Также он создаёт последовательность токенов
\begin_inset space ~
\end_inset

(и различает их по типу).
\end_layout

\begin_layout Standard
Есть так называемая 
\series bold
Таблица
\begin_inset space ~
\end_inset

символов
\series default
, проходит через все фазы компиляции.
 При создании компилятра даём множество всех лексем, разделённых на некоторые
 группы -- множества цифр, идентификтаоров, целых чисел и т.
\begin_inset space \thinspace{}
\end_inset

п.
 Правила определения группы не должны быть неоднозначны
\begin_inset space ~
\end_inset

(поэтому, например, никогда идентификаторы не начинаются с цифры).
 Тип правила, которому соответствует определённый кусок, определяет тип
 токена
\begin_inset space ~
\end_inset

(идентификатор, \SpecialChar \ldots{}
).
 Анализатор проходит слева направо, и создаёт новую строку с токенами.
 Например, взял строчку из примера, идёт, раз -- идентификатор, и идёт\SpecialChar \ldots{}
 пока
 не встретит нечто что не идентификатор.
 И пишет создаёт токен: 
\family typewriter
<id_1>.

\family default
 А в таблицу символов добавлет аля 
\family typewriter
id_1 -> newValue, float,\SpecialChar \ldots{}
 
\family default
В таблице символов в итоге содержится всё, что относится к переменным и
 идентификаторами
\begin_inset space ~
\end_inset

(заполняется не только лексическим анализатором).
 И так далее.
 Затем получаем последовательность токенов: 
\family typewriter
<id_1><=><id_2><*><3><+><id_3>.
\end_layout

\begin_layout Standard

\series bold
Синтаксический анализатор
\end_layout

\begin_layout Standard
Далее отправляем последовательность токенов Синтаксическому Анализатору,
 который должен построит дерево операций
\begin_inset space ~
\end_inset

(узлы -- операции, листья -- переменные/значения).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-1.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево операций, построенное синтаксическим анализатором
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Задача СА -- используя последовательность токенов, построит вот такое дерево.
 К Таблице Символов он обычно не обращается.
 На самом деле, дерево выглядит как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

.
 СА выцепляет заранее заданные структуры языка, преобразует их в кусочки
 дерева и затем объединяем в одно общее дерево.
 СА проверяет корректность семантики выражений
\begin_inset space ~
\end_inset

(например, нельзя прибавить строку к числу и т.
\begin_inset space \thinspace{}
\end_inset

п.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-2.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Настоящее дерево операций :D
\begin_inset CommandInset label
LatexCommand label
name "fig:Настоящее-дерево-операций"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Для построения используются определённые алгоритмы, аля BNF и т.п.
 Если СА не знает что делать, он выдаёт ошибку.
\end_layout

\begin_layout Standard

\series bold
Семантический анализатор
\end_layout

\begin_layout Standard
Но в Сем.
 Анализатор можно заложить логику, которая будет такие ошибки обходить.
 Например
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

float a = 3;        // not correct
\end_layout

\begin_layout Plain Layout

float a = (float)3; // correct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float a = 3; => float a = (float)3;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Но зачем заставлять программиста выполнять то, что может сделать СА? Поэтому,
 после СА дерево будет выглядеть как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

 + операция 
\family typewriter
<to_float> 
\family default
перед узлом 
\family typewriter
3
\family default
.
\end_layout

\begin_layout Standard
Теперь можно получить промежуточный код.
 
\end_layout

\begin_layout Standard

\series bold
Пример
\series default
.
 Пусть хотим посчитать 
\family typewriter
b = b + 3
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

# asm example
\end_layout

\begin_layout Plain Layout

# cmd   where what
\end_layout

\begin_layout Plain Layout

MOV 	Ax    %b
\end_layout

\begin_layout Plain Layout

MOV 	Bx    3
\end_layout

\begin_layout Plain Layout

ADD 	Ax    Bx
\end_layout

\begin_layout Plain Layout

MOV 	%b    Ax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Обычно промежуточное представление -- какой-либо трёхадрессный код
\begin_inset space ~
\end_inset

(что то вроде ассемблера, но высокоуровневее), а может быть и дерево.
\end_layout

\begin_layout Standard
Для примера выше:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

TOFLOAT <a> <3>
\end_layout

\begin_layout Plain Layout

MUL <b> <id_2> <b>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Трёхадрессный код легко оптимизируем
\begin_inset space ~
\end_inset

(в примере выше --- операция 
\family typewriter
TOFLOAT
\family default
 -- избыточна, можно сразу написать 
\family typewriter
3.0 .
 
\family default
Это называет 
\emph on
платформа-независимая оптимизация
\emph default
.)
\end_layout

\begin_layout Subsubsection
Синтез
\end_layout

\begin_layout Description
Синтез --- получение из промежуточного представления
\begin_inset space ~
\end_inset

(кода) конечной целевой программы.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Enumerate
(Промежуточный код/представление) --> 
\end_layout

\begin_layout Enumerate
машинно-независимые оптимизации
\begin_inset Newline newline
\end_inset

(с заданным критерием; по памяти, по скорости, по регистрам, по загружаемым
 в Java-машину классам, \SpecialChar \ldots{}

\begin_inset Note Note
status open

\begin_layout Plain Layout
switch при оптимизации преобразуется в дерево, чтобы можно было делать бинарный
 поиск,
\end_layout

\begin_layout Plain Layout
если в if некоторая ветвь выполняется в 80% случаев, то имеет смысл сдеать
 её первой
\end_layout

\end_inset

) --> 
\end_layout

\begin_layout Enumerate
(более оптимальный по какому-либо критерию промежуточный код) -->
\end_layout

\begin_layout Enumerate
генерация/преобразования целевого кода
\begin_inset space ~
\end_inset

(i.e.
 для платформы 
\family typewriter
x86
\family default
)--> 
\end_layout

\begin_layout Enumerate
(целевой код) --> 
\end_layout

\begin_layout Enumerate
машинно-зависимые оптимизации
\begin_inset Newline newline
\end_inset

(на основе архитектуры процессора) --> 
\end_layout

\begin_layout Enumerate
(
\begin_inset Quotes fld
\end_inset

оптимальный
\begin_inset Quotes frd
\end_inset

 целевой код)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Все эти фазы активно использую таблицу символов.
\end_layout

\begin_layout Standard
Имеются генераторы синтаксический анализаторов, лексических анализаторов,
 кода.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 2 // 24-фев-2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Основные понятия языков программирования
\end_layout

\begin_layout Standard

\series bold
Области видимости переменной 
\series default
(почитай о них самостоятельно в интернете):
\end_layout

\begin_layout Itemize
статические
\end_layout

\begin_layout Itemize
динамические
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

       среда               	состояние
\end_layout

\begin_layout Plain Layout

  |--------------v	|------------------v
\end_layout

\begin_layout Plain Layout

имена		ячейки памяти		значения
\end_layout

\begin_layout Plain Layout

  x		 ячейка №376		 яблоко
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Есть имя переменной.
 Оно что то значит.
 Привязано к некой ячейке памяти.
 С ячейкой памяти связано определённое значение.
 Ячейка памяти определяется или как само значение или ссылка (на другое
 значение).
\end_layout

\begin_layout Standard
Так же важна 
\series bold
блочная структура
\series default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

{ //1				
\end_layout

\begin_layout Plain Layout

	{//2	{//3 ...} }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	{//4  
\end_layout

\begin_layout Plain Layout

		{//5 ...
 <we start here>}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-stack-img.pdf
	width 100text%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-blocks.pdf
	width 100text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Как вообще стэк то работает
\begin_inset CommandInset label
LatexCommand label
name "fig:Как-вообще-стэк"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Мы в любой момент находимся в определённом блоке, и нашу позицию можно описать
 линейной последовательностью.
 Например: 
\family typewriter
1-4-5.

\family default
 Посему, обычно используют связанные списки (при компиляции).
 Смотри рисунок
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Как-вообще-стэк"

\end_inset

.
\end_layout

\begin_layout Standard
При поиске определённой переменной, идём в обратную сторону (от самого нижележащ
его блока -- вверх), как найдём переменную с таким-то именем, её и используем.
\end_layout

\begin_layout Standard
Передача переменной:
\end_layout

\begin_layout Itemize
По значению
\end_layout

\begin_layout Itemize
По адресу
\end_layout

\begin_layout Itemize
По ссылке
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsection
Построение дерева разбора
\end_layout

\begin_layout Standard
Рассмотрим фэйко-код:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

do {
\end_layout

\begin_layout Plain Layout

	int i=0;
\end_layout

\begin_layout Plain Layout

	for (int j=0; j<10; j++) i--;
\end_layout

\begin_layout Plain Layout

} while (true)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Дерево разбора не может описывать динамику приложения.
 Оно может лишь описывать некую логическую структуру.
 Осмысленную семантику мы в это не вкладываем.
 То что строки в коде выполняются последовательно, имеется ввиду, что между
 строками есть некий 
\emph on

\begin_inset Quotes fld
\end_inset

оператор порядка
\begin_inset Quotes frd
\end_inset


\emph default
.
 С точки зрения дерева -- оператора порядка нет никакого, можем лишь ввести
 искусственно.
 В языке часто не всё отражается в синтаксисе, а отражается в неких дополнительн
ых соглашениях.
 
\family typewriter
{} 
\family default
--
\family typewriter
 
\family default
тоже оператор (блочный) специально введённый, т.к.
 сам 
\family typewriter
do...while
\family default
 работает лишь с одним оператором.
 Построим начало дерева разбора:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Контекстно свободные грамматики
\end_layout

\begin_layout Plain Layout

do < оператор > while <условие>
\end_layout

\begin_layout Plain Layout

if (< условие >) <выражение>
\end_layout

\begin_layout Plain Layout

if (<условие>) <выражение> else <выражение>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
За счёт таких различных подстановок у нас есть возможность описать многие
 языки программирования.
 Это -- лишь синтаксис.
 С точки зрения семантики это ничего не значит (смысла не вкладывается).
 Результат представлен на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Примерное-дерево-разбора"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-do-while.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Схематическое дерево разбора 
\family typewriter
do...while
\begin_inset CommandInset label
LatexCommand label
name "fig:Примерное-дерево-разбора"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Контекстно-свободные грамматики (Backus-Naur Form; BNF)
\end_layout

\begin_layout Description
Контекстно-свободная
\begin_inset space ~
\end_inset

грамматика --- совокупность четырёх множеств:
\end_layout

\begin_layout Itemize
множество терминальных символов (терминалов
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
языки различаются по тому, какие терминальные символы можно использовать
\end_layout

\end_inset

) 
\family typewriter
T
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
if ( } , else while 5
\end_layout

\begin_layout Itemize
множество не терминальных символов (не терминалов) 
\family typewriter
N
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
<условие>, <выражение>, ...
\family default

\begin_inset Newline newline
\end_inset

Что-то, что можно заменить каким-либо образом на что-то.
 Смотрим по определению условия/выражения и заменяем.
 
\begin_inset Newline newline
\end_inset

Например: 
\family typewriter
if (<усл>) <выражение> => if (<усл1> && <усл2>) <выражение>
\family default

\begin_inset Newline newline
\end_inset

а определение:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<условие> := <усл> && <усл>
\end_layout

\begin_layout Plain Layout

		   ||
\end_layout

\begin_layout Plain Layout

	  	    ~
\end_layout

\end_inset

 и т.д.
 В итоге, желательно за конечное число подстановок, получаем выражение лишь
 с 
\emph on
терминальными
\emph default
 символами.
\end_layout

\begin_layout Itemize
множество правил вывода 
\family typewriter
P:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $n\in N$
\end_inset

, 
\begin_inset Formula $n:=a_{0}a_{1}a_{2}...a_{k}$
\end_inset

, 
\family default
где 
\family typewriter

\begin_inset Formula $a_{i}\in N\cup T$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $:=$
\end_inset

 или -> 
\family default
---
\family typewriter
 
\family default
символ, обозначающий: можно представить как
\end_layout

\begin_layout Itemize
множество из одного элемента -- начальный символ 
\begin_inset Formula $s\in N$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Когда производим разбор грамматики, то сначала есть 
\begin_inset Formula $s$
\end_inset

.
 
\end_layout

\begin_layout Standard
Затем: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->a+a->a+a-a->3+a-a->3+1-a->3+1-1
\end_layout

\begin_layout Plain Layout

а хотим посчитать
\end_layout

\begin_layout Plain Layout

3+1-7,
\end_layout

\begin_layout Plain Layout

с грамматикой (очень плохой, т.к.
 не однозначной):
\end_layout

\begin_layout Plain Layout

s:=a+a
\end_layout

\begin_layout Plain Layout

s:=a-a
\end_layout

\begin_layout Plain Layout

a:=a+a
\end_layout

\begin_layout Plain Layout

a:=a-a
\end_layout

\begin_layout Plain Layout

a:=0|..|9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Очевидно -- написание грамматики -- очень сложная задача.
 Точнее -- создание 
\emph on
правильной 
\emph default
грамматики.
 Поэтому обычно используют уже готовые (Например, LR-грамматика).
\end_layout

\begin_layout Standard
Напишем более простую грамматику, которая позволит разбирать такие 
\family typewriter
(3+7)*(3)+3+7
\family default
 предложения:
\end_layout

\begin_layout Itemize
Терминальные символы: 
\family typewriter
0..9, (, ), +, -, *, /
\end_layout

\begin_layout Itemize
Не терминальные: 
\family typewriter
s
\end_layout

\begin_layout Itemize
Начальный: 
\family typewriter
s
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
и напишем грамматику, которая может генерировать все возможные арифметические
 выражения:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# d -- digital -- число/цифра
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# возможные комбинации
\end_layout

\begin_layout Plain Layout

1, 3+7, (3+7)
\end_layout

\begin_layout Plain Layout

2, 3-5, (1)
\end_layout

\begin_layout Plain Layout

0, 3/7
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# переходы
\end_layout

\begin_layout Plain Layout

s->d|s+d|s-d|s*d|s/d|(s)
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# из вышенаписанного автоматически получается:
\end_layout

\begin_layout Plain Layout

(s)->(d)->(1)
\end_layout

\begin_layout Plain Layout

s+d->(s)+d->(s+d)->(d+d)+d
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Но!
\end_layout

\begin_layout Plain Layout

# 3+(7*3) мы ещё не можем.
 
\end_layout

\begin_layout Plain Layout

# Проблемка..
 как минимально улучшить?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# введём ещё переменную:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s->d|s+e|s-e|s*e|s/e|e
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

e->(e)|d|s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Вся эта грамматика очень очень плохая, т.
\begin_inset space \thinspace{}
\end_inset

к.
 при построении дерева не учитывается порядок операций.
\end_layout

\begin_layout Standard

\series bold
Пример
\series default
: 
\end_layout

\begin_layout Standard

\family typewriter
3+7*4
\end_layout

\begin_layout Standard
Дерево разбора построенное при использовании грамматики выше представлено
 на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Разбор-примера-неправильной"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-pre-final-tree.pdf
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Разбор примера неправильной грамматикой
\begin_inset CommandInset label
LatexCommand label
name "fig:Разбор-примера-неправильной"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
В итоге получим 
\family typewriter
(3+7)*4.
\end_layout

\begin_layout Subsubsection*
Приоритет и ассоциативность операций.
\end_layout

\begin_layout Standard
Если есть что-то, окружённое двумя операторами, то 2 случая -- операторы
 
\emph on
одинаковые
\emph default
 (тогда вступаем в силу правило ассоциативности -- левые или правые) или
 
\emph on
разные
\emph default
 (тогда в ступает в действие приоритет операций).
\end_layout

\begin_layout Standard
Т.
\begin_inset space \thinspace{}
\end_inset

е.
 
\family typewriter
(((3-4)-7)-9),
\family default
 и
\family typewriter
 (a=(b=(c=(4))))
\end_layout

\begin_layout Standard
Короче, как учитывать ассоциативность?! Введём ещё терминальные символы,
 для каждой из ассоциативностей:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# неплохая такая грамматика
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Боле менее адекватная грамматика
\begin_inset CommandInset label
LatexCommand label
name "fig:Боле-мене-адекватная"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Т.
\begin_inset space \thinspace{}
\end_inset

е.
 приём какой -- самые приоритетные операции должны выполнятся 
\emph on
внизу
\emph default
 дерева.
 А благодаря тому, что 
\family typewriter
k->(e), 
\family default
мы можем строить подвыражения с подобными приоритетами.
 Грамматика выше -- 
\emph on
право-рекурсивная.

\emph default
 Т.
\begin_inset space \thinspace{}
\end_inset

е.
 каждый раз заменяется правое выражение.
\end_layout

\begin_layout Standard
Самый плохой вариант, из-за неоднозначности и отсутствия приоритетов:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->s+s|s-s|s*s|s/s|0|1..9|(s)
\end_layout

\end_inset


\end_layout

\begin_layout Description
Неоднозначная грамматика -- если для одного выражения возможно построение
 2х различных деревьев.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\series bold
Пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# дано
\end_layout

\begin_layout Plain Layout

3+5*4
\end_layout

\begin_layout Plain Layout

# разбираем...
\end_layout

\begin_layout Plain Layout

s->s+s->s+s*s->...
\end_layout

\begin_layout Plain Layout

s->s*s->s+s*s->...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Такие грамматики затрудняются разбор и вносят неоднозначности.
 При построении грамматик для ЯП -- подобного стараются избегать.
\end_layout

\begin_layout Standard
Пример корректного дерева разбора (с грамматикой 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

) для выражения 
\family typewriter
3+(5*7) 
\family default
представлен на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Дерево-разбора-выражения"

\end_inset

.
 Грамматика совсем правильная, поэтому дерево не столь простое.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-real--parse-tree.pdf
	width 40text%
	BoundingBox 0bp 0bp 350bp 636bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора выражения на примере грамматики 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Дерево-разбора-выражения"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Примерчики на подумать
\end_layout

\begin_layout Subsubsection*

\series bold
Пример 1
\end_layout

\begin_layout Standard
Что будет производить код:
\end_layout

\begin_layout Standard

\family typewriter
s->+ss
\end_layout

\begin_layout Standard

\family typewriter
s->-ss
\end_layout

\begin_layout Standard

\family typewriter
s->1
\end_layout

\begin_layout Standard

\family typewriter
?
\end_layout

\begin_layout Subsubsection*

\series bold
Пример 2
\end_layout

\begin_layout Standard

\family typewriter
S->aSbS
\end_layout

\begin_layout Standard

\family typewriter
s->bSaS
\end_layout

\begin_layout Standard

\family typewriter
S->E
\end_layout

\begin_layout Standard
# 
\family typewriter
E
\family default
 (
\begin_inset Formula $\varepsilon$
\end_inset

) --- пустота, обозначение пустоты
\end_layout

\begin_layout Standard

\emph on
результат
\emph default
: строка состоящая из произвольного количества 
\family typewriter
ab
\family default
 в любых комбинациях, при этом их число равно
\end_layout

\begin_layout Subsubsection*

\series bold
Пример 3
\end_layout

\begin_layout Standard

\family typewriter
S->(S)|SS|E
\end_layout

\begin_layout Standard
Грамматика генерирует все правильные расстановки скобочек.
\end_layout

\begin_layout Subsubsection*

\series bold
Home work
\series default
:
\end_layout

\begin_layout Enumerate
Составить грамматику, генерирующую все возможные бинарные числа, делящиеся
 на 3.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

3 - 00011
\end_layout

\begin_layout Plain Layout

6 - 00110
\end_layout

\begin_layout Plain Layout

9 - 01001
\end_layout

\begin_layout Plain Layout

12- 01100
\end_layout

\begin_layout Plain Layout

15- 01111
\end_layout

\begin_layout Plain Layout

18- 10010
\end_layout

\begin_layout Plain Layout

21- 10101
\end_layout

\begin_layout Plain Layout

24- 11000
\end_layout

\begin_layout Plain Layout

27- 11011
\end_layout

\begin_layout Plain Layout

30- 11110
\end_layout

\begin_layout Plain Layout

33- 100001
\end_layout

\begin_layout Plain Layout

---
\end_layout

\begin_layout Plain Layout

выделяет паттеmрны
\end_layout

\begin_layout Plain Layout

num=11|1001|num0|numnum ...
\end_layout

\begin_layout Plain Layout

так что то не всё получается...
\end_layout

\begin_layout Plain Layout

короче не будем делать
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Составить все возможные идентификаторы Java.
\begin_inset Newline newline
\end_inset

> Правила для идентификаторов (на ключевые слова забиваем)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
буквы
\end_layout

\begin_layout Enumerate
нижнее подчёркивание
\end_layout

\begin_layout Enumerate
цифры (но не начинаться с них)
\begin_inset Newline newline
\end_inset


\family typewriter
c:=a-z|A-Z|_
\begin_inset Newline newline
\end_inset

s:=c|cd|ss|E(empty)
\begin_inset Newline newline
\end_inset

***
\begin_inset Newline newline
\end_inset

(id-> first_symbol + other_symbol)
\begin_inset Newline newline
\end_inset

id:=first_symbolother_symbol
\begin_inset Newline newline
\end_inset

first_symbol:=буква|нижние_подчёркивание
\begin_inset Newline newline
\end_inset

other_symbol:=буква_other_symbol|_other_symbol|цифра|E(empty)
\begin_inset Newline newline
\end_inset


\family default
нельзя писать:
\begin_inset Newline newline
\end_inset


\family typewriter
otherSym:=otherSym_digit|otherSym_|...
 
\family default

\begin_inset Newline newline
\end_inset

т.
\begin_inset space \thinspace{}
\end_inset

к.
 при использовании леворекурсивной грамматики будет беда.
\end_layout

\end_deeper
\begin_layout Enumerate
Добавить в грамматику
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

 унарный плюс и унарный минус.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# имеем что-то вроде:
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Модифицируем (так чтобы можно было писать +(+(-(33))):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

c->...
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

В общем случае, у нас леворекурсивный парсер,
\end_layout

\begin_layout Plain Layout

он заменяет на первый в списке элемент, т.е.
 будет
\end_layout

\begin_layout Plain Layout

e+t -> e+t+t -> e+t+t -> ...
 
\end_layout

\begin_layout Plain Layout

хрень
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Как происходит разбор то? Смотрим на первый символ
\end_layout

\begin_layout Plain Layout

(как должно, но не как есть) 
\end_layout

\begin_layout Plain Layout

e-t-k-> -c -> -(e) -> -(e+t) -> ...
 ->
\end_layout

\end_inset


\family typewriter
###
\family default

\begin_inset Newline newline
\end_inset

Почувствуйте себя синтаксическим анализатором! 
\begin_inset Newline newline
\end_inset

В следующий раз не будете просто так компилирвоать программу ;D
\begin_inset Newline newline
\end_inset


\family typewriter
###
\end_layout

\begin_layout Enumerate
Создать грамматику, позволяющую определять переменные типов 
\family typewriter
int, double 
\family default
и инициализировать их цифрами.
\begin_inset Newline newline
\end_inset

Т.
\begin_inset space \thinspace{}
\end_inset

е.
 чтобы можно было делать нечто вроде:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int a,b,c=3;
\end_layout

\begin_layout Plain Layout

int z=3, k=4;
\end_layout

\begin_layout Plain Layout

# на самом деле, z=0 сюда тоже можно легко добавить
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 3 // 03.03.2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Синтаксически-управляющая трансляция
\end_layout

\begin_layout Description
Синтаксически-управляема
\begin_inset space ~
\end_inset

трансляция --- процесс присоединения к продукциям грамматики программных
 конструкций.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->e+	{print("t")}t
\end_layout

\begin_layout Plain Layout

e->e-t	{print("-")}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Синтезированные атрибуты
\end_layout

\begin_layout Standard
Мы в соответствии с продукциями грамматики строим некое дерево разбора.
 Например, дерево для выражения 
\family typewriter
3+7/4
\family default
 представлено на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Дерево-разбора-с"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-1.pdf
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора с атрибутами
\begin_inset CommandInset label
LatexCommand label
name "fig:Дерево-разбора-с"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

С каждым узлом можем связать некий атрибут, например, 
\family typewriter
a.

\family default
 И для каждого узла надо определит правило, по которому
\family typewriter
 
\family default
атрибут вычисляется.
 
\end_layout

\begin_layout Subsubsection
Постфиксное выражение
\end_layout

\begin_layout Standard
Если 
\family typewriter
E (E) --> E (E
\family default
-переменная или константа
\family typewriter
)
\end_layout

\begin_layout Standard
Если 
\family typewriter

\begin_inset Formula $E_{1}$
\end_inset

<op>
\begin_inset Formula $E_{2}$
\end_inset

 ---> 
\begin_inset Formula $E_{1}E_{2}<op>$
\end_inset


\end_layout

\begin_layout Standard
считаем что между 
\family typewriter
E 
\family default
-- есть некий условные разделитель.
 Затем рекурсивно отдельно рассматриваем 
\begin_inset Formula $E_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(2+3) -> 2+3
\end_layout

\begin_layout Plain Layout

2+3 -> 2 3 +
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "50col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
(4*(2+4)-7)-13*2 --> ...
 -->
\end_layout

\begin_layout Standard

\family typewriter
4 2 4 + * 7 - 13 2 * -
\end_layout

\begin_layout Standard
(А в стеке потом всё хорошо сложиться..
 как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Смысл-этой-странной"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-2.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Смысл этой странной нотации на примере стэка
\begin_inset CommandInset label
LatexCommand label
name "fig:Смысл-этой-странной"

\end_inset

.
 Стэк снизу вверх
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Составим грамматику, которая будет такие выражения принимать.
 Хотим преобразовывать имплексные выражения в постфиксные.
\end_layout

\begin_layout Standard
Рассмотрим пример попроще (для понимания идеи): 
\family typewriter
((2+3)-4)+7
\family default
 .
 Дерево разбора на рисунке 3.
 Добавим в него синтезированный атрибут 
\family typewriter
s
\family default
, который будет обозначать, какая постфиксная запись у выражения.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-3.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора с атрибутом для выражения 
\family typewriter
((2+3)-4)+7
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Доработаем старую грамматику:
\end_layout

\begin_layout Plain Layout

e->e+t
\end_layout

\begin_layout Plain Layout

e->e-t
\end_layout

\begin_layout Plain Layout

e->t
\end_layout

\begin_layout Plain Layout

t-(e)
\end_layout

\begin_layout Plain Layout

t->d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Попробуем добавить каждому правилу некое семантическое правило -- см.
 столбец 2 в таблице
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Придумываем-атрибуты-по"

\end_inset


\begin_inset space ~
\end_inset

(точка -- конкатенация)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features islongtable="true" firstHeadTopDL="true" firstHeadBottomDL="true" headTopDL="true" headBottomDL="true" longtabularalignment="center">
<column alignment="center" valignment="middle" width="5cm">
<column alignment="center" valignment="middle" width="5cm">
<column alignment="center" valignment="middle" width="7cm">
<row endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Грамматика
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
способ #1
\begin_inset Newline newline
\end_inset

используем правило для вычисления атрибута по ходу разбора
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
способ #2
\begin_inset Newline newline
\end_inset

(синтаксически-управляемая трансляция)
\begin_inset Newline newline
\end_inset

происходит сразу же, при разборе
\end_layout

\end_inset
</cell>
</row>
<row caption="true">
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Придумываем атрибуты по ходу разбора дерева
\begin_inset CommandInset label
LatexCommand label
name "tab:Придумываем-атрибуты-по"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->e+t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e.t.'+'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->et{print '+'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->e-t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e.t.'-'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->et{print '-'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
t->e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
t->d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
d->0|...|9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
d->'0'|...|'9'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

d->{print'0'|...|'9'}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
d->{print'0'}|...|{print'9'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 4 // 17-03-2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Под разбором будем понимать некий процесс, позволяющий определить, может
 ли данная строка быть сгенерирована данной грамматикой.
 Результат
\begin_inset space ~
\end_inset

--- может или не может.
 Существует несколько видов разбора.
\end_layout

\begin_layout Subsubsection
Рекурсивный спуск
\end_layout

\begin_layout Standard
Для каждого нетерминала ставится в соответствие функция, рекурсивно вызывающая
 функции других нетерминалов.
\end_layout

\begin_layout Standard
Рисунок 1.
 Рассмотрим 
\emph on
преддективную
\emph default
 грамматику
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->+kle
\end_layout

\begin_layout Plain Layout

k->27d3
\end_layout

\begin_layout Plain Layout

l->-k|*d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// можем прям по ходу строить дерево
\end_layout

\begin_layout Plain Layout

void e(){ match('+'); k(); l(); e(); }
\end_layout

\begin_layout Plain Layout

void k(){ match('27');d(); match('3'); }
\end_layout

\begin_layout Plain Layout

void l(){ switch(next_char)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

		case '-': match('-');k();break;
\end_layout

\begin_layout Plain Layout

		case '*': match('*');d();break;
\end_layout

\begin_layout Plain Layout

		default: ERROR;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Алгоритм нисходящего разбора
\end_layout

\begin_layout Enumerate
Делаем стартовый символ (
\family typewriter
e
\family default
) корнем дерева.
 Задача --- для заданной строки, имея грамматику, построить дерево разбора.
\end_layout

\begin_layout Enumerate
Вызываем рекурсивную процедуру для стартового символа и добавляем в дерево
 соответствующие внутренним вызовам под узлы.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Однако, не всегда так можно сделать.
 Если продукция грамматики, например, такая:
\begin_inset Newline newline
\end_inset


\family typewriter
e->e+k
\begin_inset Newline newline
\end_inset

h->k*l
\end_layout

\begin_layout Standard
То тут всё очень плохо, т.к.
 будет следующая ситуация:
\end_layout

\begin_layout Standard

\family typewriter
void e() {e(); match('+'); k();}.

\family default
 
\end_layout

\begin_layout Standard
Упс, StackOverflow.
 Проблема грамматики в леворекурсивности.
 Необходмо просто преобразовтаь.
\end_layout

\begin_layout Description
Преддективные
\begin_inset space ~
\end_inset

парсеры --- парсеры, для которых необходимо чтобы по первому токену каждого
 правила грамматики можно было бы определить какую продукцию использовать.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*
Устранение левой рекурсивности
\end_layout

\begin_layout Standard
Рассмотрим 
\family typewriter
A->Aa|b, 
\family default
где 
\family typewriter
a
\family default
 --- некоторая строка из нетерминалов и терминалов, 
\family typewriter
b
\family default
 --- терминал.
 Явная леворекурсивная грамматика.
 
\family typewriter
A
\family default
 явно зависит от 
\family typewriter
A
\family default
.
 Все строки, которые принимает данная грамматика:
\end_layout

\begin_layout Standard

\family typewriter
b
\end_layout

\begin_layout Standard

\family typewriter
ba
\end_layout

\begin_layout Standard

\family typewriter
baa
\end_layout

\begin_layout Standard

\family typewriter
ba...a
\family default
 (
\family typewriter
n
\family default
-раз в общем случае.)
\end_layout

\begin_layout Standard
Преобразуем...
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

A->bB
\end_layout

\begin_layout Plain Layout

B->aB|E(empty)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Получили праворекурсивную грамматику.
 Проделаем тоже самое для грамматики 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# неплохая такая грамматика
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

*** Используем правило ***
\end_layout

\begin_layout Plain Layout

A->Aa|b 
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

A-> bB
\end_layout

\begin_layout Plain Layout

B->aB|E
\end_layout

\begin_layout Plain Layout

*** получаем ***
\end_layout

\begin_layout Plain Layout

> e->e+t|t
\end_layout

\begin_layout Plain Layout

e->tB
\end_layout

\begin_layout Plain Layout

B->+tB|E
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Усложним ка правило преобразования:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

A->Aa1|Aa2|b
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

A->bB
\end_layout

\begin_layout Plain Layout

B->a1B|a2B|E
\end_layout

\end_inset


\end_layout

\begin_layout Standard
И используя его, разберём всю первую строку:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

~ A->Aa1|Aa2|B
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

e->tB
\end_layout

\begin_layout Plain Layout

B->+tB|-tB|E
\end_layout

\begin_layout Plain Layout

t->kC
\end_layout

\begin_layout Plain Layout

C->*kC|/kC|E
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Эквивалентная 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

 грамматика, но без левой рекурсивности
\begin_inset CommandInset label
LatexCommand label
name "fig:Эквивалентная--грамматика,"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Проверим на примере разбора
\family typewriter
 (2+3)*5
\family default
 , что на каждом шаге мы знаем, по какому правилу мы следуем.
 Результат представлен на рисунке 2.
 Написав функции по заданному принципу, мы можем построить парсер.
 
\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection

\series bold
Домашнее задание #1
\end_layout

\begin_layout Enumerate
Написать консольную программку, которая на основе грамматики (в которую
 добавить унарные + и - ) будет преобразовывать: принимает инфиксную строку
 ( 
\family typewriter
(2+3)*4 --> + 2 3 * 4
\family default
) преобразует в преобразует префиксную форму (польская нотация).
 
\end_layout

\begin_layout Enumerate
Программку, которая вычисляет эти значения (из польской нотации).
\end_layout

\begin_layout Enumerate
Расширить грамматику 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Эквивалентная--грамматика,"

\end_inset

, для использования целых чисел (23 038 7357) и чисел с плавающей точкой
 (
\family typewriter
.23 3.
 3е15 3e+13 3e-13 3.7e10
\family default
) на бумаге.
 Кто хочет, может их и реализовать в прогах 1-2.
 Более интересный вариант задания.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Как мы помним, задача лексического анализатора --- разбиение исходной строки
 символов на токены.
 Дополнительно он может удалять некие ненужные конструкции.
 ЛА может использовать опережающее чтение.
 В идеале правила выделение не должны пересекаться (чтобы нельзя было интерпрети
ровать одну строку как цифру и как число).
 Чем проще правила для лексера, тем он эффективнее.
\end_layout

\begin_layout Standard
Как записываются токены, нам уже показывали:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# токены | # таблица символов
\end_layout

\begin_layout Plain Layout

---------|------------------
\end_layout

\begin_layout Plain Layout

<str,1>  |>1..."Вася"
\end_layout

\begin_layout Plain Layout

<num,2>  |>2...float 2.37
\end_layout

\end_inset


\end_layout

\begin_layout Standard
на вход парсеру подаются токены.
\end_layout

\begin_layout Section
Лексический анализ
\end_layout

\begin_layout Description
Лексический
\begin_inset space ~
\end_inset

анализ --- процесс преобразования входной строки символов в последовательность
 токенов.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Очевидно, не может/не должно быть, что несколько токенов соответствуют одним
 и тем же символам (нахлёст).
 У каждого токена свой тип.
 Если типа нет, то мы его не учитываем.
 
\end_layout

\begin_layout Standard

\emph on
См.
 рисунок 3 (фото).
\end_layout

\begin_layout Standard
Лексический анализатор, при необходимости, обрабатывает токены, по мере
 того как синтаксический анализатор просит у него.
 
\end_layout

\begin_layout Standard

\emph on
См.
 рисунок 4.
\end_layout

\begin_layout Standard
Можно, но не обязательно, разделить лексический анализатор на 2 части.
 Первая отсекает всё ненужное, а вторая получает непосредственно токены.
\end_layout

\begin_layout Description
Токен --- пара, состоящая из типа и необязательного параметра, ссылающегося
 на таблицу символов 
\family typewriter
<тип, ссылка>
\family default
.
\end_layout

\begin_layout Description
Шаблон
\begin_inset space ~
\end_inset

токена --- вид, который может принимать строки, соответствующие данному
 токену.
\end_layout

\begin_layout Description
Лексема --- часть строки символов, соответствующая шаблону токенов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Таким образом, лексический анализатор разбивает исходную строку в соответствии
 шаблону на лексемы, а т.к.
 каждый шаблону соответствует токену с определённым типом, то затем мы из
 лексемы создаём определённый токен.
\end_layout

\begin_layout Standard
Обычно во многих языках присутствуют токены следующих видов:
\end_layout

\begin_layout Enumerate
токены для каждого ключевого слова
\end_layout

\begin_layout Enumerate
токены для операторов
\end_layout

\begin_layout Enumerate
токены для идентификаторов 
\end_layout

\begin_layout Enumerate
токены для констант и литералов
\end_layout

\begin_layout Enumerate
токены для символов пунктуации
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Есть класс ошибок, которые называются 
\emph on
лексическими ошибками
\emph default
.
 Возникают они при преобразовании строки символов в токен.
 
\begin_inset Newline newline
\end_inset

Например: 
\family typewriter
3name = 15,4;
\end_layout

\begin_layout Standard
Л.А.
 старается выделить максимальную последовательность, соответствующую шаблону(?)/
лексеме/идентификатору.
 Это 
\family typewriter
3name.

\family default
 Но что это --- непонятно ---> поэтому ошибка.
 Далее: 3 токена: 
\family typewriter
15 , 
\family default
и
\family typewriter
 4 
\family default
.
 Ошибка (т.к.
 запятая), но не лексическая.
\end_layout

\begin_layout Standard
При возникновении таких ошибок, многие лексические анализаторы стараются
 устранить её, чтобы восстановить поток символов
\begin_inset space ~
\end_inset

(чтобы компилятор старался показать как можно больше ошибок за один проход).
\end_layout

\begin_layout Standard
Подходы устранения ошибок:
\end_layout

\begin_layout Enumerate
удаление символа;
\end_layout

\begin_layout Enumerate
добавление символа;
\end_layout

\begin_layout Enumerate
перестановка двух символов;
\end_layout

\begin_layout Enumerate
изменение символа.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Так же, можно не считывать файл целиком, а использовать двойную буферизацию.
 В первый считывают ...
 Необходимо правильно выбрать размер буфера, чтобы макс.
 идентификатор не был больше длинны буфера.
 В конце буфера можно ставить уникальный для языка символ, например 
\family typewriter
EOF
\family default
, чтобы переходить от одного буфера к другому.
\end_layout

\begin_layout Subsection
Языки, строки
\end_layout

\begin_layout Description
Алфавит --- конечное множество символов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\family typewriter
R = {a...z}
\end_layout

\begin_layout Standard

\family typewriter
Reg = {a...z,+,(,)}
\end_layout

\begin_layout Standard

\family typewriter
Rbin = {0,1}
\end_layout

\begin_layout Standard
По сути, это множество всех символов, которые могут присутствовать в файле.
\end_layout

\begin_layout Description
Строка
\begin_inset space ~
\end_inset

над
\begin_inset space ~
\end_inset

алфавитом --- конечная последовательность символов алфавита.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Например, строка 
\family typewriter
+a(*315
\family default
 --- строка над алфавитом регулярных выражений (
\family typewriter
Reg
\family default
).
\end_layout

\begin_layout Standard

\family typewriter
s 
\family default
--- строка над алфавитом.
 
\end_layout

\begin_layout Standard

\family typewriter
|s|
\family default
 --- длина строки.
 
\end_layout

\begin_layout Standard

\family typewriter
E|
\begin_inset Formula $\varepsilon$
\end_inset


\family default
 --- пустая строка.
\end_layout

\begin_layout Description
Язык --- некоторое счётное
\begin_inset space ~
\end_inset

(мб и не конечное) множество строк над алфавитом.
\end_layout

\begin_layout Description
Под
\begin_inset space ~
\end_inset

конкатенацией
\begin_inset space ~
\end_inset

строк
\begin_inset space ~
\end_inset


\family typewriter
s1
\family default

\begin_inset space ~
\end_inset

и
\begin_inset space ~
\end_inset


\family typewriter
s2
\family default
 будем понимать первую строку приписанную к ней справа вторую, т.е.
 
\family typewriter
s1s2.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Очевидно, получаются следующие правила:
\end_layout

\begin_layout Standard

\family typewriter
sE=Es=s
\end_layout

\begin_layout Standard
\begin_inset Formula $s^{0}=\varepsilon,$
\end_inset

 
\begin_inset Formula $s^{1}=s,s^{2}=ss,...,s^{n}=s^{n-1}s$
\end_inset

 (степень)
\end_layout

\begin_layout Subsubsection
Операции над языками
\end_layout

\begin_layout Standard
Пусть есть языки 
\begin_inset Formula $L_{1}$
\end_inset

 и 
\begin_inset Formula $L_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\emph on
Объединением
\emph default
 этих языков есть язык 
\begin_inset Formula $L=L_{1}\cup L_{2}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Конкатенацией
\emph default
 --- 
\begin_inset Formula $L=\{s_{1}s_{2}\},$
\end_inset

 
\begin_inset Formula $s_{1}\in L_{1},s_{2}\in L_{2}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Замыкание Клини
\emph default
 
\begin_inset Formula $L_{1}$
\end_inset

 --- 
\end_layout

\begin_layout Standard

\emph on
Положительное замыкание
\emph default
 
\begin_inset Formula $L_{1}$
\end_inset

 ---
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsubsection
Регулярные выражения
\end_layout

\begin_layout Standard
Шаблоны токенов очень удобно задавать регулярными выражениями.
\end_layout

\begin_layout Standard
Пусть есть регулярное выражение 
\family typewriter
r
\family default
, над алфавитом 
\family typewriter
А.

\family default
 Тогда применив рег.
\begin_inset space ~
\end_inset

выр.
 к языку, можем получить некий язык 
\begin_inset Formula $L(r)$
\end_inset

, над алфавитом 
\family typewriter
А
\family default
.
 
\end_layout

\begin_layout Standard
Введём базис:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\varepsilon$
\end_inset

 --- рег.выражение ---> 
\begin_inset Formula $L(\varepsilon)=\{\varepsilon\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall a\in A$
\end_inset

 --- рег.
\begin_inset space ~
\end_inset

выражение ---> 
\begin_inset Formula $L(a)=\{a\}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*

\series bold
Индукция
\end_layout

\begin_layout Standard
Если 
\begin_inset Formula $r_{1}$
\end_inset

 и 
\begin_inset Formula $r_{2}$
\end_inset

 --- рег.выражения, и 
\begin_inset Formula $L(r_{1}),L(r_{2})$
\end_inset

, то
\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{1}|r_{2}$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $L(r_{1})\cup L(r_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(r_{1})(r_{2})$
\end_inset

 --- рег.выражения, 
\begin_inset Formula $L(r_{1})L(r_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{1}^{*}$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $(L(r_{1}))^{*}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(r_{1})$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $L(r_{1})$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Попробуем теперь 
\family typewriter
[abc][def](abc)
\begin_inset Formula $^{*}$
\end_inset


\family default
 записать в наших обозначениях.
 Выйдет нечто вроде: 
\family typewriter
(((a|b)|c))(((d|e)|e))(((1)(2)(3))
\begin_inset Formula $^{*}$
\end_inset

.
 
\family default
Очевидно, что какая-то жесть\SpecialChar \ldots{}
 короче, явно не хватает правила приоритетов.
\end_layout

\begin_layout Subsubsection
Правила приоритетов
\end_layout

\begin_layout Standard
По уменьшению приоритета:
\end_layout

\begin_layout Enumerate

\family typewriter
*
\family default
 --- левоассоциативный
\end_layout

\begin_layout Enumerate
конкатенация --- левоассоцитивный
\end_layout

\begin_layout Enumerate

\family typewriter
|
\family default
 --- левоассоциативен
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Тогда уже можно переписать то выражение как 
\family typewriter
(a|b|c)(d|e|f)(123)
\begin_inset Formula $^{*}$
\end_inset


\family default
.
\end_layout

\begin_layout Subsubsection*

\series bold
Примеры
\end_layout

\begin_layout Standard

\family typewriter
(a|b)* = {E, a, b,
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}$
\end_inset


\family default
 --- любая строка из символов
\family typewriter
 a 
\family default
и
\family typewriter
 b
\end_layout

\begin_layout Standard

\family typewriter
a* = {E, a, aa, ...}
\end_layout

\begin_layout Standard

\family typewriter
ab*(c|d)* = {a, ab...b
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}\in\{c,d\}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
(ab*)* = {E, a, a
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}$
\end_inset


\family default
 --- любая выборка 
\family typewriter
a,b
\end_layout

\begin_layout Standard
((ab*)*) = ...
\end_layout

\begin_layout Standard
в общем виде, 
\family typewriter
r* = (r*)*
\family default
, т.к.
 оператор Клини идемпотентен.
\end_layout

\begin_layout Subsubsection
Законы преобразования регулярных выражений.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula $(r_{1}|r_{2})=(r_{2}|r_{1})$
\end_inset

 
\family default
// коммутативность объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}|r_{2})|r_{3}=r_{1}|(r_{2}|r_{3})$
\end_inset

 // ассоциативность объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}r_{2})r_{3}=r_{1}(r_{2}r3)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $r_{1}(r_{2}|r_{3})=r_{1}r_{2}|r_{1}r_{3}$
\end_inset

 // левая дистрибутивность конкатенации относительно объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}|r_{2})r_{3}=r_{1}r3|r_{2}r_{3}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $r*=(r|E)*$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $rE=Er=r$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(r*)*=r*$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 5 // 24-03-2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Регулярные определения
\end_layout

\begin_layout Standard
Пусть сигма --- некоторый алфавит.
 Последовательность определений
\end_layout

\begin_layout Standard

\family typewriter
d
\family default
 --- некий нетерминал.
\end_layout

\begin_layout Standard

\family typewriter
r
\family default
 --- регулярное выражение.
\end_layout

\begin_layout Standard
\begin_inset Formula $d_{1}-->r_{1}=r_{1}(\Sigma)$
\end_inset

 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset Formula $d_{n}->r_{n}=r_{n}(\Sigma,d_{1},...,d_{n-1})$
\end_inset


\end_layout

\begin_layout Standard
называется регулярным определением, если выполняются следующие условия:
\end_layout

\begin_layout Enumerate
все 
\begin_inset Formula $d_{i}$
\end_inset

 --- различны.
 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall i:\Sigma\cap\{d_{i}\}=\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{i}$
\end_inset

--- строки над алфавитом 
\begin_inset Formula $\Sigma\cup\{d_{1},...d_{i}\}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
И в чём особенность? Любое из правил можно свести к последовательности символов
 исходного алфавита.
 Т.е.
 нету регулярных зависимостей.
 
\end_layout

\begin_layout Standard
Можно написать так: 
\family typewriter
(+-)?(
\backslash
d)+
\backslash
.(
\backslash
d)*
\family default
 (рег.
 выражение в стиле Java.
 На самом деле 
\family typewriter
r+ = rr*
\family default
)
\end_layout

\begin_layout Standard
Но чтобы не повторяться, можно сказать, что:
\end_layout

\begin_layout Standard

\family typewriter
DIGIT -> 0|1|...|9
\end_layout

\begin_layout Standard

\family typewriter
SIGN -> +|-
\end_layout

\begin_layout Standard

\family typewriter
POINT -> .|,
\end_layout

\begin_layout Standard
И тогда получим:
\end_layout

\begin_layout Standard

\family typewriter
SIGN? DIGIT DIGIT* POINT DIGIT*
\end_layout

\begin_layout Subsubsection
Расширенные регулярные выражения
\end_layout

\begin_layout Standard
Мы уже знаем операции: 
\family typewriter
ab, a*, a|b
\end_layout

\begin_layout Standard
Введём сокращенные обозначяения, которые часто бывают в языках:
\end_layout

\begin_layout Itemize
\begin_inset Formula $a?=>a|\varepsilon$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $a^{+}=>aa^{*}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $[abc]=>a|b|c$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $[A-Z]=>A|B|C...|Z$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $[a-zA-Z0-9]=>A|...|Z|a|...|z|0|...|9$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $[a-z073]=>a|...|z|0|7|3$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection
Части строк
\end_layout

\begin_layout Description
Префиксом
\begin_inset space ~
\end_inset

строки --- любая строка, полученная из неё удалением 
\family typewriter
0
\family default
 или более 
\emph on
конечных
\emph default
 символов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
myname
\end_layout

\begin_layout Standard
my
\end_layout

\begin_layout Standard
myn
\end_layout

\begin_layout Standard
m
\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon$
\end_inset


\end_layout

\begin_layout Description
Суффиксом
\begin_inset space ~
\end_inset

строки --- любая строка, полученная из неё удалением 
\family typewriter
0
\family default
 или более 
\emph on
начальных
\emph default
 символов.
\end_layout

\begin_layout Description
Подстрокой
\begin_inset space ~
\end_inset

строки --- называется любая строка, полученная из исходной путём удаления
 любого префикса и суффикса.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Префикс
\begin_inset space ~
\end_inset

(суффикс) называется 
\series bold
правильным
\series default

\begin_inset space ~
\end_inset

(
\series bold
истинным
\series default
) если он не равен 
\begin_inset Formula $\varepsilon$
\end_inset

 и исходной строке.
\end_layout

\begin_layout Description
Подпоследовательностью
\begin_inset space ~
\end_inset

строки --- называется любая строка, полученная из исходной путём удаления
 
\family typewriter
0
\family default
 или более символов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection
Домашнее задание #2
\end_layout

\begin_layout Subsubsection*
Задание №1
\end_layout

\begin_layout Standard
Пусть есть языки 
\begin_inset Formula $L=\{a,...,z,A,...,Z\}$
\end_inset

, а 
\begin_inset Formula $D=\{0,...,9\}$
\end_inset

.
 Нужно 
\emph on
описать следующие языки
\emph default
:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $L\cap D$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $L^{4}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $L\cup D$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $L^{3}\cup D\cup LD$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(L^{*})D^{2}L$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $L(L\cup D)^{+}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Пример: язык 
\family typewriter
LD 
\family default
--- описывает строки вида: первый символ --- буква, второй --- цифра.
 Т.
\begin_inset space \thinspace{}
\end_inset

е.
 : 
\family typewriter
75, a1, b4, m7
\end_layout

\begin_layout Subsubsection*
Задание №2
\end_layout

\begin_layout Standard
Дана строка из 
\family typewriter
n 
\family default
символов.
 Сколько в этой строке:
\end_layout

\begin_layout Itemize
префиксов
\end_layout

\begin_layout Itemize
суффиксов
\end_layout

\begin_layout Itemize
истинных префиксов
\end_layout

\begin_layout Itemize
истинных суффиксов
\end_layout

\begin_layout Itemize
подпоследовательностей
\end_layout

\begin_layout Itemize
подстрок (имеется ввиду что есть 
\family typewriter
n
\family default
 мест)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*
Задание №3
\end_layout

\begin_layout Standard
Записать ключевое слово языка, не чувствительного к регистру (
\family typewriter
SQL
\family default
, например).
 Регулярное выражение на одно слово (ключевое).
\end_layout

\begin_layout Itemize

\family typewriter
INSERT insert iNSERT
\end_layout

\begin_layout Itemize

\family typewriter
<Html>
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*
Задание №4
\end_layout

\begin_layout Standard
Записать регулярное выражение, принимающее:
\end_layout

\begin_layout Enumerate
любые строки из различных цифр
\end_layout

\begin_layout Enumerate
комментарии 
\family typewriter
/*...*/
\end_layout

\begin_layout Enumerate
шахматные ходы 
\family typewriter
e2->e4
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*
Задание №5
\end_layout

\begin_layout Standard
bash -> reg exp (в каком либо формате)
\end_layout

\begin_layout Standard

\family typewriter
*.sh | me.sh, lala.sh
\end_layout

\begin_layout Standard

\family typewriter
?.c 
\begin_inset space ~
\end_inset

| a.c, b.c, w.c
\end_layout

\begin_layout Standard

\family typewriter
*.[co] | name.c, name.o, l.o, w.c
\end_layout

\begin_layout Standard

\family typewriter
Ex.: name*.[co].*k
\end_layout

\begin_layout Standard
Для этих трёх вариантов придумать, как их преобразовать в регулярное выражения:
\end_layout

\begin_layout Enumerate
придумать, как преобразовать посл-ность 
\family typewriter
bash
\family default
 в 
\family typewriter
regexp
\end_layout

\begin_layout Enumerate
написать грамматику для исходных выражений
\end_layout

\begin_layout Enumerate
написать транслятор 
\family typewriter
bash
\family default
 -> 
\family typewriter
regexp
\family default
 (теоретические, 
\family typewriter
*
\family default
, 
\family typewriter
|
\family default
, 
\family typewriter
+
\family default
, 
\family typewriter
?
\family default
), или в формате Java
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection
Шаблоны токенов и диаграммы переходов
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Plain Layout
слева --- нетерминал
\end_layout

\begin_layout Plain Layout
digit->
\family typewriter
[0-9]
\end_layout

\begin_layout Plain Layout
digits->
\family typewriter
digit+
\end_layout

\begin_layout Plain Layout
number->
\family typewriter
digit(.digit)?(E[+-]?digits)?
\end_layout

\begin_layout Plain Layout
letter->
\family typewriter
[a-zA-Z]
\end_layout

\begin_layout Plain Layout
id->
\family typewriter
letter(letter|digit)*
\end_layout

\begin_layout Plain Layout
if->
\family typewriter
if
\end_layout

\begin_layout Plain Layout
then->
\family typewriter
then
\end_layout

\begin_layout Plain Layout
else->
\family typewriter
else
\end_layout

\begin_layout Plain Layout
relop->
\family typewriter
 <
\family default
|
\family typewriter
>
\family default
|
\family typewriter
<=
\family default
|
\family typewriter
>=
\family default
|
\family typewriter
=
\family default
|
\family typewriter
<>
\end_layout

\begin_layout Plain Layout
ws->
\family typewriter
(blank
\family default
(
\begin_inset Quotes fld
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Quotes frd
\end_inset

)
\family typewriter
|tab
\family default
(
\backslash
t)
\family typewriter
|newline
\family default
(
\begin_inset Quotes fld
\end_inset


\backslash
n
\backslash
r
\begin_inset Quotes frd
\end_inset

)
\family typewriter
)+
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset Caption

\begin_layout Plain Layout
Грамматика
\begin_inset CommandInset label
LatexCommand label
name "fig:грамматика"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row caption="true">
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Токены, их шаблоны и значения атрибутов
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Лексема
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Имя токена
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Значение атрибута
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall ws$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
if
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
then
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
then
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
else
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
else
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall id$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
id
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
указат.
 в табл.
 символов
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\forall num$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
указат.
 в табл.
 символов
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
relop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQ
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<>
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>+=
\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GE
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Т.е., например, как только встретим 
\family typewriter
<
\family default
 , то будет 
\family typewriter
<relop,LT>
\end_layout

\begin_layout Description
Диаграмма
\begin_inset space ~
\end_inset

перехода --- помеченный ориентированный граф.
 Неформальная вещь.
 Промежуточное между регулярными выражениями и конечными автоматами.
\end_layout

\begin_layout Description
Граф --- совокупность вершин и дуг.
\end_layout

\begin_layout Description
Помеченный
\begin_inset space ~
\end_inset

граф --- каждая дуга его, помечена чем-то.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/5-state-diagram.pdf
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Пример диаграммы перехода
\begin_inset CommandInset label
LatexCommand label
name "fig:Привер-диаграммы-перехода"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Пример на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Привер-диаграммы-перехода"

\end_inset

.
\end_layout

\begin_layout Standard
Бывает состояние, когда не понятно с первого символа, какое состояние принимать.
 Например, операция 
\family typewriter
<=.

\family default
 Необходимо возвращаться назад.
 Т.е.
 если переходим в НЕ принимающее состояние(
\family typewriter
P
\family default
), но дальше идти не куда, то возвращаемся назад.
 Если из текущего состояния 
\emph on
можно
\emph default
 возвращаться назад, то оно обозначается 
\emph on
звёздочкой
\emph default
(
\family typewriter
*
\family default
).
 Если всё равно некуда идти, то строка --- ошибочная, и выдаём ошибку.
 Иллюстрация на рисунках
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Диаграмма-перехода-для"

\end_inset

\SpecialChar \nobreakdash-

\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Диаграмма-перехода-для-1"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/5-state-diagram-for-logic-operands.pdf
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Диаграмма перехода для логических операций
\begin_inset CommandInset label
LatexCommand label
name "fig:Диаграмма-перехода-для"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/5-state-diagram-for-numbers.pdf
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Диаграмма перехода для идентификаторов
\begin_inset CommandInset label
LatexCommand label
name "fig:Диаграмма-перехода-для-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection
Домашнее задание #3
\end_layout

\begin_layout Standard
Составить общую большую диаграмму переходов для всей грамматики
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:грамматика"

\end_inset

.
 
\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Формализуем ассемблер.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# секции
\end_layout

\begin_layout Plain Layout

.data
\end_layout

\begin_layout Plain Layout

A3=5
\end_layout

\begin_layout Plain Layout

B=7
\end_layout

\begin_layout Plain Layout

.code
\end_layout

\begin_layout Plain Layout

# команды (не настоящие)
\end_layout

\begin_layout Plain Layout

ADD AX BX
\end_layout

\begin_layout Plain Layout

MOV AX @0xbff360
\end_layout

\begin_layout Plain Layout

SUB AX CX
\end_layout

\begin_layout Plain Layout

MOV AX @0xbff363
\end_layout

\end_inset


\end_layout

\begin_layout Standard
фВыделяем шаблоны:
\end_layout

\begin_layout Itemize

\family typewriter
.[a-z]+ // блоки
\end_layout

\begin_layout Itemize

\family typewriter
(ADD|MOV|SUB) // команда
\end_layout

\begin_layout Itemize

\family typewriter
[A-Z]+ // идентификатор
\end_layout

\begin_layout Itemize

\family typewriter
= // присваивание
\end_layout

\begin_layout Itemize

\family typewriter
[0-9]+ // числа
\end_layout

\begin_layout Itemize

\family typewriter
@0x[a-f0-9]{6} // адрес
\end_layout

\begin_layout Itemize

\family typewriter
(AX|BX|CX) //
\family default
 регистры
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Рисунок формализации ассемблера
\end_layout

\begin_layout Standard
Эти диаграммы позволяют в достаточно простом виде представить последовательность
 действий.
 Очень простой алгоритм получения токена.
\end_layout

\begin_layout Subsection
Конечные автоматы
\end_layout

\begin_layout Standard
Конечный автомат, неформально - некоторый граф с переходами, который даёт
 один из двух вариантов ответа --- 
\begin_inset Quotes fld
\end_inset

да
\begin_inset Quotes frd
\end_inset

 или 
\begin_inset Quotes fld
\end_inset

нет
\begin_inset Quotes frd
\end_inset

.
 Все строки языка делятся автоматом на два вида --- они им либо принимаются,
 либо нет.
 В общем виде делятся на два класса:
\end_layout

\begin_layout Itemize
детерминированные.
 Всегда однозначно понятно куда идти, зная текущее состояние и следующий
 символ.
\end_layout

\begin_layout Itemize
не детерминированные.
 Не всегда понятно, куда идти.
 Может быть две дуги с одним названием.
 Например, след.
 символ - А, и есть два пути.
 Приходится пройтись по одной дуге, а потом, если не подойдёт, по другой.
 Так же, есть стрелочка - пустой символ (
\begin_inset Formula $\varepsilon$
\end_inset

).
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Не детерменированный конечный автомат (НКА) --- совпокупность:
\end_layout

\begin_layout Enumerate
Множества состояний 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Enumerate
Исходного состояния 
\begin_inset Formula $s_{0}\in S$
\end_inset


\end_layout

\begin_layout Enumerate
Множества символов алфавита 
\begin_inset Formula $\Sigma$
\end_inset


\end_layout

\begin_layout Enumerate
Функции переходов: 
\begin_inset Formula $F_{p}:(Sx\Sigma)\rightarrow B(S)$
\end_inset

, B --- булеан, множество всех подмножеств
\end_layout

\begin_layout Enumerate
Множество принимающих состояний 
\begin_inset Formula $F\subset S$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
рисуночек для функции переходов.
\end_layout

\begin_layout Standard
Пусть есть регулярное выражение: 
\family typewriter
(a|b)*bc
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row caption="true">
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Таблица переходов, задающая граф переходов
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $S|\Sigma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
e
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{2,1}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3(состояние для других символов)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Говорят, что недетерминированный конечный автомат допускает (принимает)
 данную 
\series bold
строку
\series default
(слово), если в графе перехода существует путь от 
\begin_inset Formula $s_{0}$
\end_inset

 к 
\begin_inset Formula $s\in S$
\end_inset

, такой, что последовательность символов, взятых вдоль данного пути равна
 строке.
 Через дуги пустой строки можно ходит сколь угодно много, но они не отображаются
 за дополнительные символы.
\end_layout

\begin_layout Standard

\series bold
Языком
\series default
, принимаемым НКА называется множество всех принимаемых строк(слов).
\end_layout

\begin_layout Standard
Детерменированным конечным атвоматов, называется НКА, в котором:
\end_layout

\begin_layout Enumerate
отсутствуют переходы по 
\begin_inset Formula $\varepsilon$
\end_inset

 (
\begin_inset Formula $!\exists(\diamond,\varepsilon)\rightarrow\{...\}$
\end_inset

)
\end_layout

\begin_layout Enumerate
функции переходов --- однозначны
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall(s,a)s\in S,a\in\Sigma\exists!s_{1}:(s,a)\rightarrow s_{1}$
\end_inset


\begin_inset Newline newline
\end_inset

т.е.
 нету: неоднозначностей и 
\begin_inset Formula $\varepsilon$
\end_inset

-переходов
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection
Алгоритм моделирования ДКА
\end_layout

\begin_layout Standard
Вход: строка 
\family typewriter
x
\family default
 над алфавитом 
\begin_inset Formula $\Sigma$
\end_inset

.
 Будем считать, что строка заканчивается символом 
\family typewriter
EOF
\family default
 (для простоты)
\family typewriter
.

\family default
 ДКА с множеством состояний S, принимающих F, нач.состояние 
\begin_inset Formula $s_{0}\in S$
\end_inset

 и 
\begin_inset Formula $F_{p}$
\end_inset

 --- функция перехода.
\end_layout

\begin_layout Standard
Выход: 
\begin_inset Quotes fld
\end_inset

да
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

нет
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
Пример: конечный автомат, скажет, соответствует данная строка (чему-то,
 не важно), или не соответствует.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s <- s0
\end_layout

\begin_layout Plain Layout

c <- nextChar()
\end_layout

\begin_layout Plain Layout

while (c != EOF) do {
\end_layout

\begin_layout Plain Layout

	s <- Fp(s, c)
\end_layout

\begin_layout Plain Layout

	c <- nextChar()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if(s in F) {
\end_layout

\begin_layout Plain Layout

	# F - множество принимающх состояний
\end_layout

\begin_layout Plain Layout

	return "Yes"
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

	return "No"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Теорема (Мак-Ноттона-Ямада-Томсона).
 
\end_layout

\begin_layout Standard
Любое регулярное выражение (то, которое мы здесь теоретически вводили) можно
 конвертировать в конечный автомат.
\end_layout

\begin_layout Paragraph
Доказательство.
 
\end_layout

\begin_layout Standard
Построение (алгоритм Мак-Ноттона-Ямада-Томсона).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция новая
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Алгоритм Мак-Ноттона-Ямада-Томсона
\end_layout

\begin_layout Standard
Вход: рег выражение 
\end_layout

\begin_layout Standard
Выход: НКА N, принимающий 
\end_layout

\begin_layout Standard
рис 20
\end_layout

\begin_layout Standard
Базис:
\end_layout

\begin_layout Standard
E --- рег.выр
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall a\in\sum$
\end_inset

 --- рег.выр
\end_layout

\begin_layout Standard
рис 21
\end_layout

\begin_layout Standard
E - рег.выбирает
\end_layout

\begin_layout Standard
a,b - рег выражение --> (a|b) -- рег выражение
\end_layout

\begin_layout Standard
Тем самым, мы доказали что мощность языков, регулярных выражений и недетерминиро
ванных конечных автоматов --- тоже самое.
\end_layout

\begin_layout Standard
Преобразование НКА в ДКА.
\end_layout

\begin_layout Paragraph
Теормема.
 
\end_layout

\begin_layout Standard
Любой НКА можно преобразовать в ДКА, принимающий тот же язык.
\end_layout

\begin_layout Standard
тонкость в том, что не всегда это хорошо, не всегда того стоит.
\end_layout

\begin_layout Standard
Алгоритм (построения подмножеств)
\end_layout

\begin_layout Standard
Вход НКА N
\end_layout

\begin_layout Standard
Выход ДКА D
\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}$
\end_inset

 --- таблица переходов для D.
\end_layout

\begin_layout Standard
каждое состояние D --- есть некоторое подмножество состояний N.
\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}$
\end_inset

 --- строится так, чтобы 
\begin_inset Quotes fld
\end_inset

параллельно
\begin_inset Quotes frd
\end_inset

 моделировать все переходы N.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon_{cl}$
\end_inset

 --- множество состояний НКА, достижимых из состояния s при любом 
\begin_inset Formula $\varepsilon$
\end_inset

-переходе
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\varepsilon_{cl}(T)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang russian
 --- мн-во НКА, достижимыхиз состояния 
\begin_inset Formula $s\in T$
\end_inset

 при любом кол-ве 
\begin_inset Formula $\varepsilon$
\end_inset

-переходе
\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon_{cl}(T)=\underset{s\in T}{\cup}\varepsilon_{cl}(s)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $move(T,a)$
\end_inset

 --- мн-во состояний НКА, в которых имеется переход из нек-го 
\begin_inset Formula $s\in T$
\end_inset

 при входном символе 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha=\{1,3\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon_{cl}(\alpha)=\{2,3,4\}$
\end_inset


\end_layout

\begin_layout Standard
--- --- ---
\end_layout

\begin_layout Standard
Допустим, у нас есть строка 
\begin_inset Formula $\lambda_{1},\lambda_{2},...,\lambda_{n}$
\end_inset


\end_layout

\begin_layout Standard
Считываем символ, и переходим дальше по всем возможным параллельным хождениям,
 где читаем пустоту(
\begin_inset Formula $\varepsilon$
\end_inset

).
 И так пока не дойдём до другого символа (не пустоты).
 После этого находимся одновременно в одном или нескольких состояниях.
\end_layout

\begin_layout Standard
\begin_inset Formula $s_{0}$
\end_inset

 --- стартовое состояние состояние НКА.
 
\begin_inset Formula $\varepsilon_{cl}(s_{0})$
\end_inset

 --> ДКА (весь переход).
 Значит на самом деле находимся не в одном состянии, а сразу в нескольких,
 достижимых из 
\begin_inset Formula $s_{0}$
\end_inset

 по эпсилон переходу.
\end_layout

\begin_layout Standard
Затем дошли до какого-то символа 
\family typewriter
х
\family default
.
 Находиммся в состоянии Т для ДКА, или в каком-то кол-ве состояний НКА.
\end_layout

\begin_layout Standard
Не всегда получается так, что множества получаемые в НКА --- не пересекаемые.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon_{cl}(move(T,x))=T_{1}$
\end_inset


\end_layout

\begin_layout Standard
в итоге получим нескольком нможеств, которые представляют собой состояния
 ДКА.
\end_layout

\begin_layout Standard
\begin_inset Formula $D_{st}$
\end_inset

 --- множество состояний D.
\end_layout

\begin_layout Standard
используется идея помечания того, где мы прошли.
 Когжда все множества помечены -- мы всё множество прошли.
\end_layout

\begin_layout Standard
\begin_inset Formula $D_{st}=\{\varepsilon_{cl}(s_{0})\}$
\end_inset

 и 
\begin_inset Formula $\varepsilon_{cl}(s_{0})$
\end_inset

 --- не помечены
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

while (в D есть непомеч.состояние T)
\end_layout

\begin_layout Plain Layout

  пометить T;
\end_layout

\begin_layout Plain Layout

  for(для каждогоо входного a из сигма) {
\end_layout

\begin_layout Plain Layout

    U=Ecl(move(T,a));
\end_layout

\begin_layout Plain Layout

    if (U != пустое мн-во)
\end_layout

\begin_layout Plain Layout

      добавить U в Dst
\end_layout

\begin_layout Plain Layout

      (как непомеченное сост, если U не из Dst.)
\end_layout

\begin_layout Plain Layout

    Dtran[T, a] = U;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Почитать работы академика 
\series bold
Ершова
\series default
.
\end_layout

\begin_layout Standard
ДЗ: рис.
 23
\end_layout

\begin_layout Standard
для этого НКА построить ДКА.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
лекция ++ // 14-04-2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Если множество NKA = {1,...,100}.
 Тогда возможных подмножеств: 
\begin_inset Formula $2^{100}$
\end_inset

.
 И ещё таблица переходов, т.е.
 всего: 
\begin_inset Formula $2^{100}*4*2^{100}$
\end_inset

.
 требует очень много памяти, поэтому в затратных случаях лучше эмулировать
 работу НКА.
 Для этого существует специальный алгоритм моделирования работы НКА.
\end_layout

\begin_layout Subsubsection
Алгоритм моделирования НКА
\end_layout

\begin_layout Standard

\emph on
Вход
\emph default
: НКА 
\family typewriter
N
\family default
, строка 
\family typewriter
Х
\family default
, принимающее состояние 
\family typewriter
F,
\family default
 
\family typewriter
move 
\family default
--- функции переходов, 
\begin_inset Formula $s_{0}$
\end_inset

 --- начальное состояние.
\end_layout

\begin_layout Standard

\emph on
Выход
\emph default
: Да/Нет
\end_layout

\begin_layout Standard
\begin_inset Formula $S=\varepsilon_{cl}(s_{0})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c=nextChar()$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $while$
\end_inset


\begin_inset Formula $(c!=EOF)\{$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S=\varepsilon_{cl}(move(S,c))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $c=nextChar()$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $if(S\cap F!=\textrm{Ø})$
\end_inset


\family typewriter
 then return 
\begin_inset Quotes fld
\end_inset

yes
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
else return 
\begin_inset Quotes fld
\end_inset

no
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Один конечный автомат может лишь определетиь, соответствует ли строка(целая)
 какому-либо выражениею.
 Да, или Нет.
 Но лексический анализатор должен делать не так: выбирать подстроку и указать
 её тип/лексема -> токен.
\end_layout

\begin_layout Subsection
Преобразование регулярных выражений в ДКА
\end_layout

\begin_layout Standard

\emph on
Вход
\emph default
: регулярное выражение
\end_layout

\begin_layout Standard

\emph on
Выход
\emph default
: ДКА 
\family typewriter
D
\end_layout

\begin_layout Standard
Отступление\SpecialChar \ldots{}

\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Будем называть состояние НКА 
\series bold
важным
\series default
, если из него есть хотя бы один не 
\begin_inset Formula $\varepsilon$
\end_inset

-переход.
\end_layout

\begin_layout Standard
Множества можно разделить на два типа --- 
\series bold
содержащие
\series default
 хотя бы одно 
\emph on
принимающее состояние
\emph default
, и 
\series bold
не содержащие
\series default
.
\end_layout

\begin_layout Standard

\family typewriter
nullable(n)
\family default
 --- для узла с номером 
\family typewriter
n
\family default
 булево значение, которое равно 
\family typewriter
true 
\begin_inset Formula $\Longleftrightarrow$
\end_inset

 
\family default
когда подвыражения, представляемое узлом 
\family typewriter
n
\family default
 содержит в своём языке 
\begin_inset Formula $\varepsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard

\family typewriter
firstpos(n)
\family default
 --- множество позиций в поддереве с корнем 
\family typewriter
\series bold
|n|
\series default
,
\family default
 которые соответствуют первому символу как минимум одной строке в языке
 подвыражения 
\family typewriter
\series bold
|n|
\family default
\series default
.
 (т.е.
 реально -- номера всех тех символов, с которых может начинать подвыражение)
\end_layout

\begin_layout Standard

\family typewriter
lastpos(n)
\family default
 --- множестов позиций в поддереве 
\family typewriter
|n|
\family default
, которые соответствуют последнему символу как минимум одной строки в языке
 
\family typewriter
|n|
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
followpos(p)
\family default
 --- для позиции 
\family typewriter
p
\family default
 представляет собой множество позиций 
\family typewriter
q
\family default
, в синтаксическом дереве 
\emph on
в целом
\emph default
, для которых 
\begin_inset Formula $\exists$
\end_inset

 строка 
\begin_inset Formula $x=a_{1}a_{2}...a_{n}$
\end_inset

 языка 
\begin_inset Formula $L((r)\#)$
\end_inset

, обладающая тем свойством, что 
\begin_inset Formula $\exists i$
\end_inset

, такое что 
\begin_inset Formula $a_{i}$
\end_inset

 соответствует позиции 
\family typewriter
p,
\family default
 а 
\begin_inset Formula $a_{i+1}$
\end_inset

 --- позиции 
\family typewriter
q
\family default
.
 Короче говоря, это множество состояний, в которые мы можем перейти из какой-либ
о позиции.
 Прям прям следующая позиция.
 
\family typewriter
# 
\family default
--- надо учитывать здесь, но понимать что она вспомогательная.
 Т.е.
 она вроде есть, а вроде нет.
\end_layout

\begin_layout Subsubsection*

\series bold
Пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

|n| -> (a|b)*a
\end_layout

\begin_layout Plain Layout

        1 2  3
\end_layout

\begin_layout Plain Layout

nullable(n) -> false
\end_layout

\begin_layout Plain Layout

firstpos(n) -> {1, 2, 3}
\end_layout

\begin_layout Plain Layout

lastpos(n)  -> {3}
\end_layout

\begin_layout Plain Layout

выше n -- номер узла, которые задаёт поддерево
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

followpos(1) -> {1,2,3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(a|b)*abc*#
\end_layout

\begin_layout Plain Layout

 1 2  345
\end_layout

\begin_layout Plain Layout

lastpos(b, 2) = {1,2, 3}
\end_layout

\begin_layout Plain Layout

lastpos(a, 1) = {1,2, 3}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="middle" width="3cm">
<column alignment="center" valignment="middle" width="4cm">
<column alignment="left" valignment="middle" width="4.5cm">
<column alignment="left" valignment="middle" width="4.5cm">
<row caption="true">
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Вычисление 
\family typewriter
nullable, firstpos, lastpos
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
nullable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
firstpos
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
lastpos
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
n
\family default
 --- лист, помеченный 
\begin_inset Formula $\varepsilon$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
true
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\textrm{Ø}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\textrm{Ø}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
n
\family default
 --- лист, помеченный 
\begin_inset Formula $a!=\varepsilon\in\Sigma$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
false
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{N_{\text{поз}}(a)\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{N_{\text{поз}}(a)\}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
or
\family default
 
\begin_inset Formula $b=c_{1}|c_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
nullable(
\begin_inset Formula $c_{1}$
\end_inset

)||
\begin_inset Newline newline
\end_inset

nullable(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
firstpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\begin_inset Formula $\cup$
\end_inset


\begin_inset Newline newline
\end_inset

firstpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
lastpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\begin_inset Formula $\cup$
\end_inset


\begin_inset Newline newline
\end_inset

lastpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
cat
\family default
 
\begin_inset Formula $n=c_{1}c_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
nullable(
\begin_inset Formula $c_{1}$
\end_inset

)&&
\begin_inset Newline newline
\end_inset

nullable(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
if(nullable(
\begin_inset Formula $c_{1}$
\end_inset

))
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

firstpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\begin_inset Formula $\cup$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

firstpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\begin_layout Plain Layout

\family typewriter
else firstpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
if nullable(
\begin_inset Formula $c_{2}$
\end_inset

) then
\end_layout

\begin_layout Plain Layout

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\begin_inset Formula $\cup$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

lastpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\begin_layout Plain Layout

\family typewriter
else lastpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
star 
\family default

\begin_inset Formula $n=c*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
true
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
firstpos(
\begin_inset Formula $c_{1}$
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
lastpos(
\begin_inset Formula $c_{2}$
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection
Домашнее задание #4
\end_layout

\begin_layout Itemize

\family typewriter
((ab)*|c)d*
\family default
 --- вычислить для всех поддеревьев 
\family typewriter
nullable && firstpos
\begin_inset Newline newline
\end_inset


\family default
решение: см.
 рисунок 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Разбор-примера-((ab)*|c)d*"

\end_inset

.
\end_layout

\begin_layout Itemize

\family typewriter
(a(zkz*|cd*)|k)
\family default
 ---//---
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/hw-4-0.jpg
	lyxscale 50
	width 55text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Разбор примера 
\family typewriter
((ab)*|c)d*
\begin_inset CommandInset label
LatexCommand label
name "fig:Разбор-примера-((ab)*|c)d*"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 21-апр-2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\varepsilon,\: a\in\Sigma,\: c_{1}c_{2},\: c_{1}|c_{2},\: c*$
\end_inset


\end_layout

\begin_layout Standard
Правила вычисления 
\family typewriter
followpos():
\end_layout

\begin_layout Enumerate
если 
\family typewriter
n
\family default
 --- 
\family typewriter
cat-
\family default
узел с левым операндом 
\begin_inset Formula $c_{1}$
\end_inset

 и правым операндом 
\begin_inset Formula $c_{2}$
\end_inset

, то для каждой позиции 
\family typewriter

\begin_inset Formula $i\in lastpos(c_{1})$
\end_inset

 
\family default
все позиции из 
\family typewriter
firstpos(
\begin_inset Formula $c_{2}$
\end_inset

) 
\family default
содержатся в 
\family typewriter
followpos(i)
\end_layout

\begin_layout Enumerate
если 
\family typewriter
n 
\family default
--- 
\family typewriter
star-
\family default
узел и 
\begin_inset Formula $i\in lastpos(n)$
\end_inset

, то все позиции из 
\family typewriter
firstpos(n)
\family default
 содержатся в 
\family typewriter
followpos(i)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Граф для НКА без 
\begin_inset Formula $\varepsilon$
\end_inset

-переходов будет соответствовать графу для 
\family typewriter
followpos
\family default
, если:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall$
\end_inset

 позиции из 
\family typewriter
followpos
\family default
 корня --- начальные состояния
\end_layout

\begin_layout Enumerate
каждая дуга из 
\family typewriter
i 
\family default
в 
\family typewriter
j
\family default
 помечена символом из позиции 
\family typewriter
i
\end_layout

\begin_layout Enumerate
позиция, связанная с 
\family typewriter
#
\family default
 --- является единственным принимаемым состоянием
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection
Алгоритм построения ДКА из регулярного выражения:
\end_layout

\begin_layout Standard

\emph on
Вход
\emph default
: регуляное выражение 
\family typewriter
r
\end_layout

\begin_layout Standard

\emph on
Выход
\emph default
: ДКА 
\family typewriter
D,
\family default
 распознающий язык 
\family typewriter
L(r)
\end_layout

\begin_layout Standard
Если по простому:
\end_layout

\begin_layout Enumerate
построить синтаксическое дерево 
\family typewriter
T
\family default
 для 
\family typewriter
(r)#
\end_layout

\begin_layout Enumerate
вычисляем для узлов дерева функции:
\end_layout

\begin_deeper
\begin_layout Enumerate

\family typewriter
nullable
\end_layout

\begin_layout Enumerate

\family typewriter
firstpos
\end_layout

\begin_layout Enumerate

\family typewriter
lastpos
\end_layout

\begin_layout Enumerate

\family typewriter
followpos
\end_layout

\end_deeper
\begin_layout Enumerate
строим 
\begin_inset Formula $D_{states}$
\end_inset

 --- множество состояний ДКА, и 
\begin_inset Formula $D_{tran}$
\end_inset

 --- функция переходов; 
\begin_inset Newline newline
\end_inset

при этом состояние автомата 
\family typewriter
D
\family default
 --- множество позиций в дереве 
\family typewriter
T
\family default
; 
\begin_inset Newline newline
\end_inset

изначально все состояния --- 
\series bold
не
\series default
 помечены (помечаем когда начинаем рассматривать).
 
\begin_inset Newline newline
\end_inset

Начальное состояние автомата 
\family typewriter
D
\family default
 --- 
\family typewriter
firstpos(
\begin_inset Formula $n_{0}$
\end_inset

), где 
\family default

\begin_inset Formula $n_{0}$
\end_inset

 --- корень 
\family typewriter
T.
\begin_inset Newline newline
\end_inset


\family default
Принимающее состояние автомата 
\family typewriter
D 
\family default
--- состояние, в которое входит 
\family typewriter
#.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\series bold
Алгоритм
\end_layout

\begin_layout Standard
Инициализируем 
\begin_inset Formula $D_{states}=\{firstpos(n_{0})\}$
\end_inset

, где 
\begin_inset Formula $n_{0}$
\end_inset

-корень 
\family typewriter
T.
\end_layout

\begin_layout Standard

\family typewriter
while (
\begin_inset Formula $\exists d\in D_{stats}$
\end_inset

 
\family default
такое что 
\family typewriter
d 
\family default
--- не помеч.
\family typewriter
) 
\end_layout

\begin_layout Standard

\family typewriter
{
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family default
помечаем 
\family typewriter
d
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for (
\begin_inset Formula $\forall a\in\Sigma$
\end_inset

)
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

{
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family default

\begin_inset Formula $U$
\end_inset

 --- объедин.
 
\family typewriter
followpos(p)
\family default
 для 
\family typewriter

\begin_inset Formula $\forall p\in d$
\end_inset

,
\family default
 которые соответствуют 
\family typewriter
a
\family default
;
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $U=\underset{\underset{p\:\text{соотв.}\: a}{\forall p\in d}}{\cup}followpos(p)$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if (
\begin_inset Formula $U\notin D_{states}$
\end_inset

)
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\family default
добавить 
\family typewriter

\begin_inset Formula $U$
\end_inset


\family default
 в 
\family typewriter

\begin_inset Formula $D_{states}$
\end_inset

 
\family default
в качестве нового состояния
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Formula $D_{tran}[d,a]=U$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

}
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection
Домашнее задание #5
\end_layout

\begin_layout Standard
Преобразовать регулярные выражения в ДКА.
\end_layout

\begin_layout Itemize

\family typewriter
(a|b)*ab*c
\end_layout

\begin_layout Itemize

\family typewriter
((ab)*c*(d|e))*
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\align center

\color red
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "90text%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Рассмотрим похожий пример: 
\family typewriter
(a|b)*abb
\end_layout

\begin_layout Standard

\emph on
Шаг 1
\emph default
: строим дерево разбора, находим 
\family typewriter
nullable,firstpos,lastpos
\family default
.
 (см.
\begin_inset space ~
\end_inset

рис.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Строим-дерево-разбора"

\end_inset

)
\end_layout

\begin_layout Standard
Шаг 2:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula $A=\{1,2,3\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B=\{1,2,3,4\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[A,a]=\{1,2,3,4\}\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[A,b]=A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[B,a]=B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[B,b]=\{1,2,3,5\}=C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[C,a]=B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[C,b]=\{1,2,3,6\}=D$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[D,a]=B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{tran}[D,b]=\{1,2,3\}=A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/hw-5-1.jpg
	lyxscale 30
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Строим дерево разбора для регулярного выражения
\begin_inset space ~
\end_inset


\family typewriter
(a|b)*abb
\begin_inset CommandInset label
LatexCommand label
name "fig:Строим-дерево-разбора"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Результирующий ДКА представлен на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ДКА-для-регулярного"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/hw-5-2.jpg
	lyxscale 30
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ДКА для регулярного выражения 
\family typewriter
(a|b)*abb
\begin_inset CommandInset label
LatexCommand label
name "fig:ДКА-для-регулярного"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 28-апр-2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Алгоритм минимизации количества состояний ДКА
\end_layout

\begin_layout Standard
Будем говорить, что ДКА_1 и ДКА_2 
\series bold
эквиваленты
\series default
, если они принимают один и тот же язык.
 
\end_layout

\begin_layout Standard
Будем говорить, что ДКА_1 
\series bold
изоморфен
\series default
 ДКА_2, если один из них можно получить из другого путём простого переименования
 состояний (
\begin_inset Formula $\text{ДКА}_{1}\sim\text{ДКА}_{2}$
\end_inset

).
 Название состояний в ДКА, в принципе, не важно.
 Важно
\begin_inset space ~
\end_inset

--- какой язык он принимает.
 Можно думать об автомате как о графе.
 Таким образом, нам необходимо получить один из возможных изоморфных состояний,
 с минимальным количеством состояний.
\end_layout

\begin_layout Paragraph*
Теорема.
\end_layout

\begin_layout Standard
Для любого регулярного языка 
\begin_inset Formula $\exists!$
\end_inset

 с точностью до изоморфизма ДКА, принимающий этот язык, с минимальным количество
м состояний.
\end_layout

\begin_layout Standard
Некоторое состояние 
\family typewriter
s
\family default
 назовём 
\series bold
отличимым
\series default
 от состояния 
\family typewriter
t
\family default
, если существует строка, которая их различает.
\end_layout

\begin_layout Standard
Все состояния 
\family typewriter
S
\family default
:
\end_layout

\begin_layout Itemize
множество принимающих состояний 
\family typewriter
A
\end_layout

\begin_layout Itemize
множество не принимающих состояний 
\family typewriter
B
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Formula $S=A\cup B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A=\{s_{1},...s_{k}\}$
\end_inset

 и 
\begin_inset Formula $a\in\Sigma$
\end_inset

.
 Может ли 
\family typewriter
a
\family default
 отличить некоторые 
\begin_inset Formula $s_{i}$
\end_inset

, 
\begin_inset Formula $s_{j}\in A$
\end_inset


\end_layout

\begin_layout Standard
Рассматриваем:
\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{1}$
\end_inset

 по 
\family typewriter
a
\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{2}$
\end_inset

 по 
\family typewriter
a
\end_layout

\begin_layout Itemize
\SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{k}$
\end_inset

 по 
\family typewriter
a
\family default
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Если мы по каким-либо 
\begin_inset Formula $s_{i}/s_{j}$
\end_inset

 переходим по 
\family typewriter
a
\family default
 в разные состояния, то разбиваем их в разные группы:
\end_layout

\begin_layout Standard
\begin_inset Formula $A_{1}=\{...s_{i}...\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A_{2}=\{...s_{j}...\}$
\end_inset


\end_layout

\begin_layout Subsubsection*

\series bold
Алгоритм
\end_layout

\begin_layout Standard

\emph on
Вход:
\emph default
 ДКА 
\family typewriter
D
\family default
 c множеством состояний 
\family typewriter
S
\family default
, алфавитом сигма, начальным состоянием 
\begin_inset Formula $s_{0}$
\end_inset

 и множеством принимающих состояний 
\family typewriter
F
\family default
.
\end_layout

\begin_layout Standard

\emph on
Выход
\emph default
: ДКА 
\family typewriter
D'
\family default
, с минимальным кол-вом состояний, принимающий тот же язык, что и 
\family typewriter
D
\family default
.
\end_layout

\begin_layout Enumerate
Разбиение 
\begin_inset Formula $P=\{F,S\backslash F\}$
\end_inset


\end_layout

\begin_layout Enumerate
Принимаем к 
\family typewriter
P
\family default
 
\emph on
функцию построения разбиения.

\emph default
 
\begin_inset Formula $P\::\: P_{new}=f(P)$
\end_inset


\end_layout

\begin_layout Enumerate
Если 
\begin_inset Formula $P_{new}==P,$
\end_inset

 то принимаем 
\begin_inset Formula $P_{final}=P$
\end_inset

 и переходим к след.шагу.
 Иначе --- переходим к предыдущему шагу, принимая 
\begin_inset Formula $P\leftarrow P_{new}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Для каждого 
\begin_inset Formula $P_{i}\in P_{final},$
\end_inset

 выбираем 
\begin_inset Formula $p_{i}\in P_{i}$
\end_inset

(некоторое состояние --- представитель).
 Тогда 
\begin_inset Formula $\{p_{i}\}$
\end_inset

 --- состояние 
\begin_inset Formula $D'$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
начальным состоянием будет 
\begin_inset Formula $p_{j}\in P_{j}$
\end_inset

, в которое входит состояние 
\begin_inset Formula $s_{0}\in P_{j}$
\end_inset

 автомата 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Enumerate
принимающими состояниями 
\begin_inset Formula $p_{r_{1}},...,p_{r_{k}}$
\end_inset

 являются такие 
\begin_inset Formula $p_{r_{i}}$
\end_inset

, что 
\begin_inset Formula $p_{r_{i}}\in P_{r_{i}}\:\&\: P_{r_{i}}\cap F\neq\textrm{Ø}$
\end_inset


\end_layout

\begin_layout Enumerate
если 
\begin_inset Formula $p_{i}\in P_{i}$
\end_inset

 и переход 
\begin_inset Formula $D_{tran}[p_{i},a]==t$
\end_inset

, то 
\begin_inset Formula $D'_{tran}[p_{i},a]=p_{j}$
\end_inset

, где 
\begin_inset Formula $t\in P_{j}$
\end_inset


\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Standard

\family typewriter
f
\end_layout

\begin_layout Standard
Вход: 
\begin_inset Formula $P$
\end_inset


\end_layout

\begin_layout Standard
Выход: 
\begin_inset Formula $P_{new}$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "50col%"
height "0.5pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $P_{new}=P$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
for (
\begin_inset Formula $\forall G\in P$
\end_inset

) {
\end_layout

\begin_layout Standard
разбиваем 
\family typewriter
G
\family default
 на подгруппы, такие, что два состояния 
\family typewriter
s
\family default
 и 
\family typewriter
t
\family default
 находятся в одной подгруппе 
\begin_inset Formula $\Longleftrightarrow$
\end_inset

 когда 
\begin_inset Formula $\forall a\in\Sigma$
\end_inset

 состоянию 
\family typewriter
s
\family default
 и 
\family typewriter
t
\family default
 имеют переходы по этому символу
\begin_inset space ~
\end_inset

(по 
\family typewriter
a
\family default
) в одну и ту же группу 
\begin_inset Formula $\overset{\sim}{G}\in P$
\end_inset

.
\end_layout

\begin_layout Standard

\family typewriter
}
\end_layout

\begin_layout Standard
мы полностью рассмотрели лексический анализ и алгоритмы лексического анализа.
\end_layout

\begin_layout Section
Синтаксический анализ
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/syn-an-1.jpg
	lyxscale 50
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Части разборщика исходной программы
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Два метода синтаксического анализа:
\end_layout

\begin_layout Itemize
нисходящий
\begin_inset space ~
\end_inset

(top-down).
 Идём от корня вниз и строим дерево.
 Класс грамматик:
\family typewriter

\begin_inset space ~
\end_inset

LL(n)
\end_layout

\begin_layout Itemize
восходящий
\begin_inset space ~
\end_inset

(botton-up).
 Всё наоборот.
 Строим ветви и поднимаемся вверх.
 Класс грамматик:
\begin_inset space ~
\end_inset


\family typewriter
LR(n)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\family typewriter
n
\family default
 --- какое количество токенов вперёд нужно прочесть.
\end_layout

\begin_layout Standard

\family typewriter
L
\family default
 первое - читаем слева на право
\end_layout

\begin_layout Standard

\family typewriter
L|R
\family default
 второе - с какой стороны строим дерево --- слева|справа
\end_layout

\begin_layout Standard
Рассмотрим грамматику:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

E->E+T|T
\end_layout

\begin_layout Plain Layout

T->T*F|F
\end_layout

\begin_layout Plain Layout

F->(E)|id
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Такая грамматика --- леворекурсивная, и чтобы использовать её в рекурсивных
 парсерах, её нужно преобразовать в не-леворекурсивную.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

E->TE'
\end_layout

\begin_layout Plain Layout

E'->+TE'|epsilon
\end_layout

\begin_layout Plain Layout

T->FT'
\end_layout

\begin_layout Plain Layout

T'->*FT'|epsilon
\end_layout

\begin_layout Plain Layout

F->(E)|id
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Синтаксические ошибки
\end_layout

\begin_layout Subsubsection
Стратегии восстановления
\end_layout

\begin_layout Subsubsection*
Восстановление в режиме паники
\end_layout

\begin_layout Standard
При встрече неправильного токена, можно выкинуть всё, пока не найдём конец
 токена, или не дойдя до начала следующего (ищем реперную точку) --- конец
 блока/функции в С-подобном языке, конец файла и т.
\begin_inset space \thinspace{}
\end_inset

п.
\end_layout

\begin_layout Subsubsection*
Восстановление на уровне фразы
\end_layout

\begin_layout Standard
Внутри скобок произошла ошибка
\begin_inset space ~
\end_inset

--- доходим до следующей закрывающей скобки, и затем будто ничего и не было.
\end_layout

\begin_layout Subsubsection*
Продукции ошибок
\end_layout

\begin_layout Standard
Есть ошибки, которые пользователи совершают очень часто.
 Чтобы корректно их интерпретировать --- необходимо расширить грамматику,
 как-будто бы правильными действиями, но реакция на эти блоки/ситуации ---
 выдача ошибки определенного рода.
\end_layout

\begin_layout Standard
То есть вносим два правила
\begin_inset space ~
\end_inset

--- с точкой запитой, и без.
 В одном случае
\begin_inset space ~
\end_inset

--- компилируемся, в другом
\begin_inset space ~
\end_inset

--- показываем ошибку.
 Но с точки зрения синтаксического анализатора
\begin_inset space ~
\end_inset

--- всё корректно и ему не нужно восстанавливаться после ошибки.
\end_layout

\begin_layout Subsubsection*
Глобальная коррекция.
\end_layout

\begin_layout Standard
Пытаемся глобально оптимизировать.
 Компилятор пытается проанализировать и найти в чём проблема.
 С точки зрения пользователя, это иногда может быть фатально
\begin_inset space ~
\end_inset

(например, VS кучу ошибок сыпит из-за отсутствия точки с запятой в конце
 класса).
\end_layout

\begin_layout Subsection
Порождение
\end_layout

\begin_layout Standard
Рассмотрим грамматику для арифметики
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

E->E+E|E*E|-E|(E)|id
\end_layout

\end_inset


\end_layout

\begin_layout Standard
И выражение: 
\family typewriter
2*(3+5).

\family default
 Как оно разбирается? Берем первый символ/нетерминал, и подставляем вместо
 него некую правую часто продукции.
 
\end_layout

\begin_layout Standard

\family typewriter
E=>E*E
\end_layout

\begin_layout Standard
Т.е.
 из 
\family typewriter
E
\family default
 мы порождаем 
\family typewriter
E*E
\family default
.
 Далее берём второй символ..
 и пока не получим выражение похожее на пример:
\end_layout

\begin_layout Standard

\family typewriter
E=>E*E=>E*(E)=>E*(E+E)=>...id*(id+id)
\end_layout

\begin_layout Standard
Продукция выводится/порождается из другой продукции.
\end_layout

\begin_layout Standard
Пусть А --- нетерминал и 
\begin_inset Formula $\alpha A\beta$
\end_inset

, где 
\begin_inset Formula $\alpha,\beta$
\end_inset

 --- произвольные
\begin_inset space ~
\end_inset

(мб даже пустые) строки, пусть 
\begin_inset Formula $A\rightarrow\gamma$
\end_inset

, тогда 
\series bold
порождением за один шаг
\series default
 называется преобразование 
\begin_inset Formula $\alpha A\beta\rightarrow\alpha\gamma\beta$
\end_inset


\end_layout

\begin_layout Standard
Если 
\begin_inset Formula $\exists$
\end_inset

 последовательность 
\begin_inset Formula $\alpha_{1},...\alpha_{n}$
\end_inset

, такая что 
\begin_inset Formula $\alpha_{1}\Rightarrow\alpha_{2}\Rightarrow...\Rightarrow\alpha_{n}$
\end_inset

, то говорят, что 
\begin_inset Formula $\alpha_{1}$
\end_inset


\series bold
порождает
\series default
 
\begin_inset Formula $\alpha_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
Если хотим обозначения порождения:
\end_layout

\begin_layout Itemize
за 0 и > шагов --- 
\begin_inset Formula $\Rightarrow^{*}$
\end_inset


\end_layout

\begin_layout Itemize
за 1 и > шагов --- 
\begin_inset Formula $\Rightarrow^{+}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Пусть 
\begin_inset Formula $s_{0}$
\end_inset

 --- стартовый символ грамматики 
\family typewriter
G
\family default
 и 
\begin_inset Formula $s_{0}\Rightarrow^{*}\alpha$
\end_inset

, то 
\begin_inset Formula $\alpha$
\end_inset

 --- 
\series bold
сентенциальная форма
\series default
 
\family typewriter
G
\family default
.
\end_layout

\begin_layout Standard

\series bold
Предложением 
\family typewriter
G
\family default
\series default
 называется сентенциальная форма, состоящая только из терминалов.
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
Некая строка терминалов 
\begin_inset Formula $w\in L(G)\Leftrightarrow s_{0}\Rightarrow^{*}w$
\end_inset

.
 (
\begin_inset Formula $s_{0}$
\end_inset

 --- стартовый символ)
\end_layout

\begin_layout Standard
на каждом шаге можем выбирать произвольный нетерминал, или левый, или правый,
 или ещё какой-нибудь.
 Это правильно, но неоднозначно, возможно много вариантов.
 Для внесения однозначности, рассматривают 2 граничных случая
\begin_inset space ~
\end_inset

--- рассмотрения самого левого терминала и самого правого.
 Таким образом:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\underset{lm}{\Rightarrow\beta}$
\end_inset

 --- левое порождение
\begin_inset space ~
\end_inset

(left most).
 
\begin_inset Formula $\beta$
\end_inset

 --- левая сентенциальная форма
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\underset{rm}{\Rightarrow\beta}$
\end_inset

 --- правое порождение
\begin_inset space ~
\end_inset

(right most)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Из порождения (однозначного) можно всегда получить дерево и обратно.
 Например, у меня есть левое порождение...
 тогда имея дерево можем получить алгоритм порождения назад.
 Так как у дерева теряется последовательность порождений, необходима однозначнос
ть.
 На рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Дерево,-теряющее-порядок"

\end_inset

 представлено дерево разбора для примера выше.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/syn-an-2.jpg
	lyxscale 50
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево, теряющее порядок порождений
\begin_inset CommandInset label
LatexCommand label
name "fig:Дерево,-теряющее-порядок"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph*
Теорема.
 
\end_layout

\begin_layout Standard
Любое регулярное выражение можно представить в виде контекстно свободно
 грамматики.
\end_layout

\begin_layout Standard

\series bold
Док-во
\series default

\begin_inset space ~
\end_inset

(конструктивное; привести алгоритм)
\end_layout

\begin_layout Standard
Возьмем НКА, представленное регулярным выражением
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall$
\end_inset

 состояние 
\family typewriter
i
\family default
 в НКА создаем нетерминал 
\begin_inset Formula $A_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
Если состояние 
\family typewriter
i
\family default
 имеет переход по в состояние 
\family typewriter
j
\family default
 по символу 
\family typewriter
a
\family default
, то добавляем в грамматику продукцию 
\begin_inset Formula $A_{i}\rightarrow aA_{j}$
\end_inset

, (если переход по 
\begin_inset Formula $\varepsilon$
\end_inset

, 
\begin_inset Formula $A_{i}\rightarrow A_{j}$
\end_inset

).
\end_layout

\begin_layout Enumerate
Если 
\family typewriter
i
\family default
 --- принимающее состояние, то 
\begin_inset Formula $A_{i}\rightarrow\varepsilon$
\end_inset


\end_layout

\begin_layout Enumerate
Если 
\family typewriter
i
\family default
 --- начальное состояние, делаем 
\begin_inset Formula $A_{i}$
\end_inset

 --- стартовым символом
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\series bold
Чтд.
\end_layout

\begin_layout Standard
Теорема говорит о том, что язык контекстно свободной грамматики как минимум
 такой же мощности как язык регулярных выражений.
 На самом деле, этот язык более обширный.
 Есть такие вещи, которые сделать в контексте свободной грамматике --- очень
 легко.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $L=\{a^{n}b^{n}|n\geq1\}.\;\underset{n}{\underbrace{a...a}}\underset{n}{\underbrace{b...b}}.\; A\rightarrow aAb|ab$
\end_inset


\end_layout

\begin_layout Standard
Докажем, что 
\family typewriter
L
\family default
 --- нельзя представить регулярным выражением.
\end_layout

\begin_layout Standard
Пусть это возможно, тогда 
\begin_inset Formula $\exists$
\end_inset

 ДКА D, с 
\family typewriter
k
\family default
 состояниями 
\begin_inset Formula $\underset{k}{\underbrace{a...a}a}$
\end_inset

.
 Тогда при строке длиннее 
\family typewriter
k
\family default
 мы перейдем в одно из уже пройденных состояний 
\begin_inset Formula $s_{i}$
\end_inset

.
 Иллюстрация на рисунке 3.19.
\end_layout

\begin_layout Standard
рис 3.19.
 (потерялся =( )
\end_layout

\begin_layout Standard
Это значит, что наш конечный автомат принимает строку, 
\begin_inset Formula $a^{i}b^{j}$
\end_inset

, а в общем случае 
\begin_inset Formula $a\neq b$
\end_inset

.
 У нас всего 
\family typewriter
k
\family default
 состояний, а хотим получить 
\family typewriter
k+1
\family default
, значит, по принципу Дирехле, мы вернемся в уже пройденное состояний.
 Т.
\begin_inset space \thinspace{}
\end_inset

е.
 ДКА принимает не только наш язык, а ещё кучу всего
\begin_inset space ~
\end_inset

(а согласно условию, должен только наш язык).
\end_layout

\begin_layout Standard
( Если принимается язык --- то принимается только то, что в него включено.
 )
\end_layout

\begin_layout Subsection
Не контекстно-свободные языки
\end_layout

\begin_layout Standard
\begin_inset Formula $L=\{wcw|w\in(a|b)*\}$
\end_inset


\end_layout

\begin_layout Standard
Нельзя построить контекстно-свободную грамматику, которая принимает вот
 такой вот язык.
 Нельзя определить, объявлена ли переменная.
\end_layout

\begin_layout Standard
\begin_inset Formula $L=\{a\}$
\end_inset


\end_layout

\begin_layout Standard
Синтаксические спецификации --- маленькие, а все остальное --- объяснение,
 что когда можно использовать и как.
\end_layout

\begin_layout Standard
\begin_inset Formula $L=\{a^{n}b^{m}c^{n}d^{m}|n\geq1,\; m\geq1\}$
\end_inset


\end_layout

\begin_layout Subsection

\series bold
Левая факторизация
\end_layout

\begin_layout Standard
Преобразование грамматики в пригодный для нисходящего анализа вид
\end_layout

\begin_layout Standard

\lang english
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

S-> *if* E *then* S *else* S |
\end_layout

\begin_layout Plain Layout

    *if* E *then* S
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# solution
\end_layout

\begin_layout Plain Layout

S-> if A'...
\end_layout

\begin_layout Plain Layout

A'->...
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
*terminal_symbols*
\end_layout

\begin_layout Standard
Непонятно, какую продукцию выбирать, чей 
\series bold
else
\series default
.
\end_layout

\begin_layout Standard
Рассмотрим эту задачу в более общей постановке.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula $A\rightarrow\alpha\beta_{1}|\alpha\beta_{2}$
\end_inset


\end_layout

\begin_layout Standard
входной поток; 
\begin_inset Formula $\alpha...$
\end_inset


\end_layout

\begin_layout Standard
тогда
\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula $A\rightarrow\alpha A_{1}$
\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula $A'\rightarrow\beta_{1}|\beta_{2}$
\end_inset


\end_layout

\begin_layout Standard
С точки зрения леворекурсивной грамматики --- проблема лишь с производительность
ю.
 
\end_layout

\begin_layout Standard
Нисходящий синтаксический анализ --- процесс построения дерева разбора из
 входной строки, начиная с корня и создавая узлы при обходе в глубину.
\end_layout

\begin_layout Subsection

\series bold
Синтаксический анализ методом рекурсивного спуска
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall A$
\end_inset

 --- нетерминал 
\begin_inset Formula $\rightarrow A()$
\end_inset

.
 (Функция на языке программирования)
\end_layout

\begin_layout Standard
Пример;
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void A() {
\end_layout

\begin_layout Plain Layout

    выбираем А-продукцию  A->X1...Xk
\end_layout

\begin_layout Plain Layout

    for (i=1..k) {
\end_layout

\begin_layout Plain Layout

        if (X_i - нетерминал)
\end_layout

\begin_layout Plain Layout

             X_i();
\end_layout

\begin_layout Plain Layout

        else if (X_i равно текущему входному символу а)
\end_layout

\begin_layout Plain Layout

             -> переод к след.сивмовлу
\end_layout

\begin_layout Plain Layout

        else ERROR!
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another way:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<---состояния
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
aK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ac
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Х
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Х
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Х
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^символы^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Получили 
\family typewriter
LL(1)
\family default
 Грамматику.
 Если можно построить такую таблицу однозначным образом
\end_layout

\begin_layout Standard
abc
\end_layout

\begin_layout Standard
S->B->Ac->aK
\end_layout

\begin_layout Standard
некоторых значений в таблице может не существовать
\end_layout

\end_body
\end_document
