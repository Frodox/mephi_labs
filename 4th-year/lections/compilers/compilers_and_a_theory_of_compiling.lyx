#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\begin_preamble

\usepackage{cmap}	  % support of searching russian words in PDF
\usepackage[T2C]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{enumitem}

\usepackage{indentfirst}	%красная строка
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding cp1251
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 14
\spacing single
\use_hyperref true
\pdf_title "Компиляторы"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 1cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle plain
\listings_params "basicstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Компиляторы и теория компиляции
\end_layout

\begin_layout Author
Ибрагимов Арсен Мирзахмедович
\end_layout

\begin_layout Date
feb 2014 --- may 2014
\end_layout

\begin_layout Right Address
k8-361, НИЯУ 
\begin_inset Quotes fld
\end_inset

МИФИ
\begin_inset Quotes frd
\end_inset


\begin_inset Newline newline
\end_inset

ver.
 0.5
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Введение
\end_layout

\begin_layout Description
Язык
\begin_inset space ~
\end_inset

программирования --- формальный способ описания вычислений для людей и машин.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Каждый раз повышая абстрактность, мы привносим ограничения.
 При переходе к процедурному программированию, уже не можем 
\begin_inset Quotes fld
\end_inset

прыгать
\begin_inset Quotes frd
\end_inset

 в любое место программы.
 От процедурного к ООП -- надо думать в терминах классов.
 Современные языки стараются уменьшить вероятность ошибок, привнося больше
 абстракции.
 Ещё более высокие
\begin_inset space ~
\end_inset

(SQL; сиквел), делаются для конкретных задач, ограничивает ещё сильнее
\begin_inset space ~
\end_inset

(нет циклов, например).
 Каждое привнесение абстракции усложняет/затрудняет его преобразование в
 машинный код
\begin_inset space ~
\end_inset

(код платформы).
 Чем высокоуровневее язык, тем сложнее пеперести код в машинный.
 Идеально оптимизированный код -- вообще говоря, NP\SpecialChar \nobreakdash-
полная задача.
\end_layout

\begin_layout Standard
Рассмотри 2 способа работы:
\end_layout

\begin_layout Enumerate
|src| → |компилятор| → |машинный код| → исполняем
\end_layout

\begin_deeper
\begin_layout Itemize
+: быстрая работа
\end_layout

\begin_layout Itemize
--: код под определённую платформу
\end_layout

\end_deeper
\begin_layout Enumerate
|src| → |интерпретатор| → исполняем каждую инструкцию
\end_layout

\begin_deeper
\begin_layout Itemize
+: лучшее отслеживание ошибок (в Runtime)
\end_layout

\begin_layout Itemize
+: возможность Runtime оптимизаций (Jit)
\end_layout

\begin_layout Itemize
--: медленно работает
\end_layout

\end_deeper
\begin_layout --Separator--

\end_layout

\begin_layout Standard
Так же, 
\family typewriter
Jit
\family default
 компилятор может на ходу менять то, что ранее было скомпилировано (подстраивать
ся под работу системы, компилируя те куски которые чаще всего используются).
\end_layout

\begin_layout Description
Компилятор
\begin_inset space ~
\end_inset

(транслятор) --- некоторое приложение, переводящее программу написанную
 на некотором языке, называемом 
\emph on
исходным,
\emph default
 в 
\emph on
эквивалентную
\emph default

\begin_inset space ~
\end_inset

(должна делать то же самое; эмулировать side-эффекты) программу на другом
 языке, называемым 
\emph on
целевым
\emph default
.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Тоже самое! Т.е.
 имея 2 программы, с двумя входами и двумя выходами, одинаковыми, мы никогда
 их не отличим.
 Т.е.
 подразумеваются именно side-эффекты
\begin_inset space ~
\end_inset

(хорошо бы, чтобы они были реализованы быстро и оптимально).
\end_layout

\begin_layout Subsection
Компиляция
\end_layout

\begin_layout Description
Компиляция -- процесс перевода из исходного языка в целевой.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Состоит из нескольких частей:
\end_layout

\begin_layout Enumerate
Анализ
\end_layout

\begin_layout Enumerate
Синтез
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Itemize
исходный код -- | анализ | --> промежуточное представление -- |
\begin_inset space ~
\end_inset

синтез
\begin_inset space ~
\end_inset

| --> целевой код
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Таким образом задача перевода из одних языков в другие сводится из 
\family typewriter
nxm
\family default
 к 
\family typewriter
n+m
\family default
.
 Важно хорошо выбрать промежуточный код
\begin_inset space ~
\end_inset

(пример -- 
\family typewriter
Gnu
\begin_inset space ~
\end_inset

Compiler
\begin_inset space ~
\end_inset

Collection
\family default
).
\end_layout

\begin_layout Subsubsection
Анализ
\end_layout

\begin_layout Standard

\series bold
Принцип работы
\end_layout

\begin_layout Standard
(Исходный язык) --> лексический анализатор --> 
\begin_inset Newline newline
\end_inset

(последовательность токенов) --> синтаксический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтаксическре дерево) --> семантический анализатор --> 
\begin_inset Newline newline
\end_inset

(абстрактное синтактическое дерево
\begin_inset space ~
\end_inset

v2
\begin_inset space ~
\end_inset

[промежуточное состояние])\SpecialChar \ldots{}
 --> генератор промежуточного кода
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

example:
\end_layout

\begin_layout Plain Layout

newValue = oldValue*3 + module
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Лексический анализатор
\end_layout

\begin_layout Standard
Лексический анализатор разбивает код на 
\emph on
лексемы
\emph default
 -- связанные/целостные куски.
 Из примера выше: 
\family typewriter
newValue, =, oldValue, *, 3, +, module.
\family default
Также он создаёт последовательность токенов
\begin_inset space ~
\end_inset

(и различает их по типу).
\end_layout

\begin_layout Standard
Есть так называемая 
\series bold
Таблица
\begin_inset space ~
\end_inset

символов
\series default
, проходит через все фазы компиляции.
 При создании компилятра даём множество всех лексем, разделённых на некоторые
 группы -- множества цифр, идентификтаоров, целых чисел и т.
\begin_inset space \thinspace{}
\end_inset

п.
 Правила определения группы не должны быть неоднозначны
\begin_inset space ~
\end_inset

(поэтому, например, никогда идентификаторы не начинаются с цифры).
 Тип правила, которому соответствует определённый кусок, определяет тип
 токена
\begin_inset space ~
\end_inset

(идентификатор, \SpecialChar \ldots{}
).
 Анализатор проходит слева направо, и создаёт новую строку с токенами.
 Например, взял строчку из примера, идёт, раз -- идентификатор, и идёт\SpecialChar \ldots{}
 пока
 не встретит нечто что не идентификатор.
 И пишет создаёт токен: 
\family typewriter
<id_1>.

\family default
 А в таблицу символов добавлет аля 
\family typewriter
id_1 -> newValue, float,\SpecialChar \ldots{}
 
\family default
В таблице символов в итоге содержится всё, что относится к переменным и
 идентификаторами
\begin_inset space ~
\end_inset

(заполняется не только лексическим анализатором).
 И так далее.
 Затем получаем последовательность токенов: 
\family typewriter
<id_1><=><id_2><*><3><+><id_3>.
\end_layout

\begin_layout Standard

\series bold
Синтаксический анализатор
\end_layout

\begin_layout Standard
Далее отправляем последовательность токенов Синтаксическому Анализатору,
 который должен построит дерево операций
\begin_inset space ~
\end_inset

(узлы -- операции, листья -- переменные/значения).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-1.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево операций, построенное синтаксическим анализатором
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Задача СА -- используя последовательность токенов, построит вот такое дерево.
 К Таблице Символов он обычно не обращается.
 На самом деле, дерево выглядит как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

.
 СА выцепляет заранее заданные структуры языка, преобразует их в кусочки
 дерева и затем объединяем в одно общее дерево.
 СА проверяет корректность семантики выражений
\begin_inset space ~
\end_inset

(например, нельзя прибавить строку к числу и т.
\begin_inset space \thinspace{}
\end_inset

п.)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/1-tree-2.pdf
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Настоящее дерево операций :D
\begin_inset CommandInset label
LatexCommand label
name "fig:Настоящее-дерево-операций"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Для построения используются определённые алгоритмы, аля BNF и т.п.
 Если СА не знает что делать, он выдаёт ошибку.
\end_layout

\begin_layout Standard

\series bold
Семантический анализатор
\end_layout

\begin_layout Standard
Но в Сем.
 Анализатор можно заложить логику, которая будет такие ошибки обходить.
 Например
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

float a = 3;        // not correct
\end_layout

\begin_layout Plain Layout

float a = (float)3; // correct
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

float a = 3; => float a = (float)3;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Но зачем заставлять программиста выполнять то, что может сделать СА? Поэтому,
 после СА дерево будет выглядеть как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Настоящее-дерево-операций"

\end_inset

 + операция 
\family typewriter
<to_float> 
\family default
перед узлом 
\family typewriter
3
\family default
.
\end_layout

\begin_layout Standard
Теперь можно получить промежуточный код.
 
\end_layout

\begin_layout Standard

\series bold
Пример
\series default
.
 Пусть хотим посчитать 
\family typewriter
b = b + 3
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

# asm example
\end_layout

\begin_layout Plain Layout

# cmd   where what
\end_layout

\begin_layout Plain Layout

MOV 	Ax    %b
\end_layout

\begin_layout Plain Layout

MOV 	Bx    3
\end_layout

\begin_layout Plain Layout

ADD 	Ax    Bx
\end_layout

\begin_layout Plain Layout

MOV 	%b    Ax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Обычно промежуточное представление -- какой-либо трёхадрессный код
\begin_inset space ~
\end_inset

(что то вроде ассемблера, но высокоуровневее), а может быть и дерево.
\end_layout

\begin_layout Standard
Для примера выше:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

TOFLOAT <a> <3>
\end_layout

\begin_layout Plain Layout

MUL <b> <id_2> <b>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Трёхадрессный код легко оптимизируем
\begin_inset space ~
\end_inset

(в примере выше --- операция 
\family typewriter
TOFLOAT
\family default
 -- избыточна, можно сразу написать 
\family typewriter
3.0 .
 
\family default
Это называет 
\emph on
платформа-независимая оптимизация
\emph default
.)
\end_layout

\begin_layout Subsubsection
Синтез
\end_layout

\begin_layout Description
Синтез --- получение из промежуточного представления
\begin_inset space ~
\end_inset

(кода) конечной целевой программы.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Enumerate
(Промежуточный код/представление) --> 
\end_layout

\begin_layout Enumerate
машинно-независимые оптимизации
\begin_inset Newline newline
\end_inset

(с заданным критерием; по памяти, по скорости, по регистрам, по загружаемым
 в Java-машину классам, \SpecialChar \ldots{}

\begin_inset Note Note
status open

\begin_layout Plain Layout
switch при оптимизации преобразуется в дерево, чтобы можно было делать бинарный
 поиск,
\end_layout

\begin_layout Plain Layout
если в if некоторая ветвь выполняется в 80% случаев, то имеет смысл сдеать
 её первой
\end_layout

\end_inset

) --> 
\end_layout

\begin_layout Enumerate
(более оптимальный по какому-либо критерию промежуточный код) -->
\end_layout

\begin_layout Enumerate
генерация/преобразования целевого кода
\begin_inset space ~
\end_inset

(i.e.
 для платформы 
\family typewriter
x86
\family default
)--> 
\end_layout

\begin_layout Enumerate
(целевой код) --> 
\end_layout

\begin_layout Enumerate
машинно-зависимые оптимизации
\begin_inset Newline newline
\end_inset

(на основе архитектуры процессора) --> 
\end_layout

\begin_layout Enumerate
(
\begin_inset Quotes fld
\end_inset

оптимальный
\begin_inset Quotes frd
\end_inset

 целевой код)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Все эти фазы активно использую таблицу символов.
\end_layout

\begin_layout Standard
Имеются генераторы синтаксический анализаторов, лексических анализаторов,
 кода.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 2 // 24-фев-2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Основные понятия языков программирования
\end_layout

\begin_layout Standard

\series bold
Области видимости переменной 
\series default
(почитай о них самостоятельно в интернете):
\end_layout

\begin_layout Itemize
статические
\end_layout

\begin_layout Itemize
динамические
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

       среда               	состояние
\end_layout

\begin_layout Plain Layout

  |--------------v	|------------------v
\end_layout

\begin_layout Plain Layout

имена		ячейки памяти		значения
\end_layout

\begin_layout Plain Layout

  x		 ячейка №376		 яблоко
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Есть имя переменной.
 Оно что то значит.
 Привязано к некой ячейке памяти.
 С ячейкой памяти связано определённое значение.
 Ячейка памяти определяется или как само значение или ссылка (на другое
 значение).
\end_layout

\begin_layout Standard
Так же важна 
\series bold
блочная структура
\series default
.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

{ //1				
\end_layout

\begin_layout Plain Layout

	{//2	{//3 ...} }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	{//4  
\end_layout

\begin_layout Plain Layout

		{//5 ...
 <we start here>}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-stack-img.pdf
	width 100text%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-blocks.pdf
	width 100text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Как вообще стэк то работает
\begin_inset CommandInset label
LatexCommand label
name "fig:Как-вообще-стэк"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Мы в любой момент находимся в определённом блоке, и нашу позицию можно описать
 линейной последовательностью.
 Например: 
\family typewriter
1-4-5.

\family default
 Посему, обычно используют связанные списки (при компиляции).
 Смотри рисунок
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Как-вообще-стэк"

\end_inset

.
\end_layout

\begin_layout Standard
При поиске определённой переменной, идём в обратную сторону (от самого нижележащ
его блока -- вверх), как найдём переменную с таким-то именем, её и используем.
\end_layout

\begin_layout Standard
Передача переменной:
\end_layout

\begin_layout Itemize
По значению
\end_layout

\begin_layout Itemize
По адресу
\end_layout

\begin_layout Itemize
По ссылке
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsection
Построение дерева разбора
\end_layout

\begin_layout Standard
Рассмотрим фэйко-код:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

do {
\end_layout

\begin_layout Plain Layout

	int i=0;
\end_layout

\begin_layout Plain Layout

	for (int j=0; j<10; j++) i--;
\end_layout

\begin_layout Plain Layout

} while (true)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Дерево разбора не может описывать динамику приложения.
 Оно может лишь описывать некую логическую структуру.
 Осмысленную семантику мы в это не вкладываем.
 То что строки в коде выполняются последовательно, имеется ввиду, что между
 строками есть некий 
\emph on

\begin_inset Quotes fld
\end_inset

оператор порядка
\begin_inset Quotes frd
\end_inset


\emph default
.
 С точки зрения дерева -- оператора порядка нет никакого, можем лишь ввести
 искусственно.
 В языке часто не всё отражается в синтаксисе, а отражается в неких дополнительн
ых соглашениях.
 
\family typewriter
{} 
\family default
--
\family typewriter
 
\family default
тоже оператор (блочный) специально введённый, т.к.
 сам 
\family typewriter
do...while
\family default
 работает лишь с одним оператором.
 Построим начало дерева разбора:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Контекстно свободные грамматики
\end_layout

\begin_layout Plain Layout

do < оператор > while <условие>
\end_layout

\begin_layout Plain Layout

if (< условие >) <выражение>
\end_layout

\begin_layout Plain Layout

if (<условие>) <выражение> else <выражение>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
За счёт таких различных подстановок у нас есть возможность описать многие
 языки программирования.
 Это -- лишь синтаксис.
 С точки зрения семантики это ничего не значит (смысла не вкладывается).
 Результат представлен на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Примерное-дерево-разбора"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-do-while.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Схематическое дерево разбора 
\family typewriter
do...while
\begin_inset CommandInset label
LatexCommand label
name "fig:Примерное-дерево-разбора"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Контекстно-свободные грамматики (Backus-Naur Form; BNF)
\end_layout

\begin_layout Description
Контекстно-свободная
\begin_inset space ~
\end_inset

грамматика --- совокупность четырёх множеств:
\end_layout

\begin_layout Itemize
множество терминальных символов (терминалов
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
языки различаются по тому, какие терминальные символы можно использовать
\end_layout

\end_inset

) 
\family typewriter
T
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
if ( } , else while 5
\end_layout

\begin_layout Itemize
множество не терминальных символов (не терминалов) 
\family typewriter
N
\family default

\begin_inset Newline newline
\end_inset


\family typewriter
<условие>, <выражение>, ...
\family default

\begin_inset Newline newline
\end_inset

Что-то, что можно заменить каким-либо образом на что-то.
 Смотрим по определению условия/выражения и заменяем.
 
\begin_inset Newline newline
\end_inset

Например: 
\family typewriter
if (<усл>) <выражение> => if (<усл1> && <усл2>) <выражение>
\family default

\begin_inset Newline newline
\end_inset

а определение:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<условие> := <усл> && <усл>
\end_layout

\begin_layout Plain Layout

		   ||
\end_layout

\begin_layout Plain Layout

	  	    ~
\end_layout

\end_inset

 и т.д.
 В итоге, желательно за конечное число подстановок, получаем выражение лишь
 с 
\emph on
терминальными
\emph default
 символами.
\end_layout

\begin_layout Itemize
множество правил вывода 
\family typewriter
P:
\begin_inset Newline newline
\end_inset


\begin_inset Formula $n\in N$
\end_inset

, 
\begin_inset Formula $n:=a_{0}a_{1}a_{2}...a_{k}$
\end_inset

, 
\family default
где 
\family typewriter

\begin_inset Formula $a_{i}\in N\cup T$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $:=$
\end_inset

 или -> 
\family default
---
\family typewriter
 
\family default
символ, обозначающий: можно представить как
\end_layout

\begin_layout Itemize
множество из одного элемента -- начальный символ 
\begin_inset Formula $s\in N$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Когда производим разбор грамматики, то сначала есть 
\begin_inset Formula $s$
\end_inset

.
 
\end_layout

\begin_layout Standard
Затем: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->a+a->a+a-a->3+a-a->3+1-a->3+1-1
\end_layout

\begin_layout Plain Layout

а хотим посчитать
\end_layout

\begin_layout Plain Layout

3+1-7,
\end_layout

\begin_layout Plain Layout

с грамматикой (очень плохой, т.к.
 не однозначной):
\end_layout

\begin_layout Plain Layout

s:=a+a
\end_layout

\begin_layout Plain Layout

s:=a-a
\end_layout

\begin_layout Plain Layout

a:=a+a
\end_layout

\begin_layout Plain Layout

a:=a-a
\end_layout

\begin_layout Plain Layout

a:=0|..|9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Очевидно -- написание грамматики -- очень сложная задача.
 Точнее -- создание 
\emph on
правильной 
\emph default
грамматики.
 Поэтому обычно используют уже готовые (Например, LR-грамматика).
\end_layout

\begin_layout Standard
Напишем более простую грамматику, которая позволит разбирать такие 
\family typewriter
(3+7)*(3)+3+7
\family default
 предложения:
\end_layout

\begin_layout Itemize
Терминальные символы: 
\family typewriter
0..9, (, ), +, -, *, /
\end_layout

\begin_layout Itemize
Не терминальные: 
\family typewriter
s
\end_layout

\begin_layout Itemize
Начальный: 
\family typewriter
s
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
и напишем грамматику, которая может генерировать все возможные арифметические
 выражения:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# d -- digital -- число/цифра
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# возможные комбинации
\end_layout

\begin_layout Plain Layout

1, 3+7, (3+7)
\end_layout

\begin_layout Plain Layout

2, 3-5, (1)
\end_layout

\begin_layout Plain Layout

0, 3/7
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# переходы
\end_layout

\begin_layout Plain Layout

s->d|s+d|s-d|s*d|s/d|(s)
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# из вышенаписанного автоматически получается:
\end_layout

\begin_layout Plain Layout

(s)->(d)->(1)
\end_layout

\begin_layout Plain Layout

s+d->(s)+d->(s+d)->(d+d)+d
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#Но!
\end_layout

\begin_layout Plain Layout

# 3+(7*3) мы ещё не можем.
 
\end_layout

\begin_layout Plain Layout

# Проблемка..
 как минимально улучшить?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# введём ещё переменную:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s->d|s+e|s-e|s*e|s/e|e
\end_layout

\begin_layout Plain Layout

d->0|1|2|3...|9
\end_layout

\begin_layout Plain Layout

e->(e)|d|s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Вся эта грамматика очень очень плохая, т.
\begin_inset space \thinspace{}
\end_inset

к.
 при построении дерева не учитывается порядок операций.
\end_layout

\begin_layout Standard

\series bold
Пример
\series default
: 
\end_layout

\begin_layout Standard

\family typewriter
3+7*4
\end_layout

\begin_layout Standard
Дерево разбора построенное при использовании грамматики выше представлено
 на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Разбор-примера-неправильной"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-pre-final-tree.pdf
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Разбор примера неправильной грамматикой
\begin_inset CommandInset label
LatexCommand label
name "fig:Разбор-примера-неправильной"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
В итоге получим 
\family typewriter
(3+7)*4.
\end_layout

\begin_layout Subsubsection*
Приоритет и ассоциативность операций.
\end_layout

\begin_layout Standard
Если есть что-то, окружённое двумя операторами, то 2 случая -- операторы
 
\emph on
одинаковые
\emph default
 (тогда вступаем в силу правило ассоциативности -- левые или правые) или
 
\emph on
разные
\emph default
 (тогда в ступает в действие приоритет операций).
\end_layout

\begin_layout Standard
Т.
\begin_inset space \thinspace{}
\end_inset

е.
 
\family typewriter
(((3-4)-7)-9),
\family default
 и
\family typewriter
 (a=(b=(c=(4))))
\end_layout

\begin_layout Standard
Короче, как учитывать ассоциативность?! Введём ещё терминальные символы,
 для каждой из ассоциативностей:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# неплохая такая грамматика
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Боле менее адекватная грамматика
\begin_inset CommandInset label
LatexCommand label
name "fig:Боле-мене-адекватная"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Т.
\begin_inset space \thinspace{}
\end_inset

е.
 приём какой -- самые приоритетные операции должны выполнятся 
\emph on
внизу
\emph default
 дерева.
 А благодаря тому, что 
\family typewriter
k->(e), 
\family default
мы можем строить подвыражения с подобными приоритетами.
 Грамматика выше -- 
\emph on
право-рекурсивная.

\emph default
 Т.
\begin_inset space \thinspace{}
\end_inset

е.
 каждый раз заменяется правое выражение.
\end_layout

\begin_layout Standard
Самый плохой вариант, из-за неоднозначности и отсутствия приоритетов:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

s->s+s|s-s|s*s|s/s|0|1..9|(s)
\end_layout

\end_inset


\end_layout

\begin_layout Description
Неоднозначная грамматика -- если для одного выражения возможно построение
 2х различных деревьев.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\series bold
Пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# дано
\end_layout

\begin_layout Plain Layout

3+5*4
\end_layout

\begin_layout Plain Layout

# разбираем...
\end_layout

\begin_layout Plain Layout

s->s+s->s+s*s->...
\end_layout

\begin_layout Plain Layout

s->s*s->s+s*s->...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Такие грамматики затрудняются разбор и вносят неоднозначности.
 При построении грамматик для ЯП -- подобного стараются избегать.
\end_layout

\begin_layout Standard
Пример корректного дерева разбора (с грамматикой 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

) для выражения 
\family typewriter
3+(5*7) 
\family default
представлен на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Дерево-разбора-выражения"

\end_inset

.
 Грамматика совсем правильная, поэтому дерево не столь простое.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/2-real--parse-tree.pdf
	width 40text%
	BoundingBox 0bp 0bp 350bp 636bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора выражения на примере грамматики 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:Дерево-разбора-выражения"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph*
Примерчики на подумать
\end_layout

\begin_layout Standard

\series bold
Пример 1
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Что будет производить код:
\end_layout

\begin_layout Plain Layout

s->+ss
\end_layout

\begin_layout Plain Layout

s->-ss
\end_layout

\begin_layout Plain Layout

s->1
\end_layout

\begin_layout Plain Layout

?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Пример 2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

S->aSbS
\end_layout

\begin_layout Plain Layout

s->bSaS
\end_layout

\begin_layout Plain Layout

S->E
\end_layout

\begin_layout Plain Layout

# E (эпсилон) -- пустота, обозначение пустоты
\end_layout

\begin_layout Plain Layout

результат: строка состоящая из произвольного кол-ва ab 
\end_layout

\begin_layout Plain Layout

в любых комбинациях, при этом их число равно
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Пример 3
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

S->(S)|SS|E
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# result
\end_layout

\begin_layout Plain Layout

грамматика генерирует все правильные расстановки скобочек
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Home work
\series default
:
\end_layout

\begin_layout Enumerate
Составить грамматику, генерирующую все возможные бинарные числа, делящиеся
 на 3.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

3 - 00011
\end_layout

\begin_layout Plain Layout

6 - 00110
\end_layout

\begin_layout Plain Layout

9 - 01001
\end_layout

\begin_layout Plain Layout

12- 01100
\end_layout

\begin_layout Plain Layout

15- 01111
\end_layout

\begin_layout Plain Layout

18- 10010
\end_layout

\begin_layout Plain Layout

21- 10101
\end_layout

\begin_layout Plain Layout

24- 11000
\end_layout

\begin_layout Plain Layout

27- 11011
\end_layout

\begin_layout Plain Layout

30- 11110
\end_layout

\begin_layout Plain Layout

33- 100001
\end_layout

\begin_layout Plain Layout

---
\end_layout

\begin_layout Plain Layout

выделяет паттеmрны
\end_layout

\begin_layout Plain Layout

num=11|1001|num0|numnum ...
\end_layout

\begin_layout Plain Layout

так что то не всё получается...
\end_layout

\begin_layout Plain Layout

короче не будем делать
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Составить все возможные идентификаторы Java.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

правила_для_идентификаторов (на ключевые слова забиваем)
\end_layout

\begin_layout Plain Layout

* буквы
\end_layout

\begin_layout Plain Layout

* ниж подчёркивание
\end_layout

\begin_layout Plain Layout

* цифры (но не начинаться с них)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c:=a-z|A-Z|_
\end_layout

\begin_layout Plain Layout

s:=c|cd|ss|E(empty)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

***
\end_layout

\begin_layout Plain Layout

(id-> first_symbol + other_symbol)
\end_layout

\begin_layout Plain Layout

id:=first_symbolother_symbol
\end_layout

\begin_layout Plain Layout

first_symbol:=буква|нижние_подчёркивание
\end_layout

\begin_layout Plain Layout

other_symbol:=буква_other_symbol|_other_symbol|цифра|E(empty)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

нельзя писать 	otherSym:=otherSym_digit|otherSym_|...
 
\end_layout

\begin_layout Plain Layout

т.к.
 при использовани леворекурсивной грамматики будет беда.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Добавить в грамматику
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

 унарный плюс и унарный минус.
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# имеем что-то вроде:
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Модифицируем (так чтобы можно было писать +(+(-(33))):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

c->...
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

В общем случае, у нас леворекурсивный парсер,
\end_layout

\begin_layout Plain Layout

он заменяет на первый в списке элемент, т.е.
 будет
\end_layout

\begin_layout Plain Layout

e+t -> e+t+t -> e+t+t -> ...
 
\end_layout

\begin_layout Plain Layout

хрень
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Как происходит разбор то? Смотрим на первый символ
\end_layout

\begin_layout Plain Layout

(как должно, но не как есть) e-t-k-> -c -> -(e) -> -(e+t) -> ...
 ->
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

###
\end_layout

\begin_layout Plain Layout

Почувствуйте себя синтаксическим анализатором! 
\end_layout

\begin_layout Plain Layout

В следующий раз не будете просто так компилирвоать программу ;D
\end_layout

\begin_layout Plain Layout

###
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Создать грамматику, позволяющую определять переменные типов 
\family typewriter
int, double 
\family default
и инициализировать их цифрами.
\begin_inset Newline newline
\end_inset

Т.
\begin_inset space \thinspace{}
\end_inset

е.
 чтобы можно было делать нечто вроде:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int a,b,c=3;
\end_layout

\begin_layout Plain Layout

int z=3, k=4;
\end_layout

\begin_layout Plain Layout

# на самом деле, z=0 сюда тоже можно легко добавить
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 3 // 03.03.2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Синтаксически-управляющая трансляция
\end_layout

\begin_layout Standard
Процесс присоединения к продукциям грамматики программных конструкций
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->e+	{print("t")}t
\end_layout

\begin_layout Plain Layout

e->e-t   {print("-")}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Синтезированные атрибуты
\end_layout

\begin_layout Standard
Мы в соответствии с продукциями грамматики строим некое дерево разбора.
\end_layout

\begin_layout Standard
Например, дерево для выражения 
\family typewriter
3+7/4
\family default
 представлено на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Дерево-разбора-с"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-1.pdf
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора с атрибутами
\begin_inset CommandInset label
LatexCommand label
name "fig:Дерево-разбора-с"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

С каждым узлом можем связать некий атрибут, например, 
\family typewriter
a.

\family default
 И для каждого узла надо определит правило, по которому
\family typewriter
 
\family default
атрибут вычисляется.
 
\end_layout

\begin_layout Subsubsection
Постфиксное выражение
\end_layout

\begin_layout Standard
Если 
\family typewriter
E (E) --> E (E
\family default
-переменная или константа
\family typewriter
)
\end_layout

\begin_layout Standard
Если 
\family typewriter

\begin_inset Formula $E_{1}$
\end_inset

<op>
\begin_inset Formula $E_{2}$
\end_inset

 ---> 
\begin_inset Formula $E_{1}E_{2}<op>$
\end_inset


\end_layout

\begin_layout Standard
считаем что между 
\family typewriter
E 
\family default
-- есть некий условные разделитель.
 Затем рекурсивно отдельно рассматриваем 
\begin_inset Formula $E_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(2+3) -> 2+3
\end_layout

\begin_layout Plain Layout

2+3 -> 2 3 +
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "50col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
(4*(2+4)-7)-13*2 --> ...
 -->
\end_layout

\begin_layout Standard

\family typewriter
4 2 4 + * 7 - 13 2 * -
\end_layout

\begin_layout Standard
(А в стеке потом всё хорошо сложиться..
 как на рисунке
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Смысл-этой-странной"

\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-2.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Смысл этой странной нотации на примере стэка
\begin_inset CommandInset label
LatexCommand label
name "fig:Смысл-этой-странной"

\end_inset

.
 Стэк снизу вверх
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Составим грамматику, которая будет такие выражения принимать.
 Хотим преобразовывать имплексные выражения в постфиксные.
\end_layout

\begin_layout Standard
Рассмотрим пример попроще (для понимания идеи): 
\family typewriter
((2+3)-4)+7
\family default
 .
 Дерево разбора на рисунке 3.
 Добавим в него синтезированный атрибут 
\family typewriter
s
\family default
, который будет обозначать, какая постфиксная запись у выражения.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename imgs/3-3.pdf
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Дерево разбора с атрибутом для выражения 
\family typewriter
((2+3)-4)+7
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Доработаем старую грамматику:
\end_layout

\begin_layout Plain Layout

e->e+t
\end_layout

\begin_layout Plain Layout

e->e-t
\end_layout

\begin_layout Plain Layout

e->t
\end_layout

\begin_layout Plain Layout

t-(e)
\end_layout

\begin_layout Plain Layout

t->d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Попробуем добавить каждому правилу некое семантическое правило -- см.
 столбец 2 в таблице
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Придумываем-атрибуты-по"

\end_inset


\begin_inset space ~
\end_inset

(точка -- конкатенация)
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features islongtable="true" firstHeadTopDL="true" firstHeadBottomDL="true" headTopDL="true" headBottomDL="true" longtabularalignment="center">
<column alignment="center" valignment="middle" width="5cm">
<column alignment="center" valignment="middle" width="5cm">
<column alignment="center" valignment="middle" width="7cm">
<row endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Грамматика
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
способ #1
\begin_inset Newline newline
\end_inset

используем правило для вычисления атрибута по ходу разбора
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
способ #2
\begin_inset Newline newline
\end_inset

(синтаксически-управляемая трансляция)
\begin_inset Newline newline
\end_inset

происходит сразу же, при разборе
\end_layout

\end_inset
</cell>
</row>
<row caption="true">
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Придумываем атрибуты по ходу разбора дерева
\begin_inset CommandInset label
LatexCommand label
name "tab:Придумываем-атрибуты-по"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->e+t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e.t.'+'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->et{print '+'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->e-t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e.t.'-'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->et{print '-'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e->t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
t->e
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
t->d
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="middle" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
d->0|...|9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
d->'0'|...|'9'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

d->{print'0'|...|'9'}
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
d->{print'0'}|...|{print'9'}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 4 // 17-03-2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Под разбором будем понимать некий процесс, позволяющий определить, может
 ли данная строка быть сгенерирована данной грамматикой.
 Результат
\begin_inset space ~
\end_inset

--- может или не может.
 Существует несколько видов разбора.
\end_layout

\begin_layout Subsubsection
Рекурсивный спуск
\end_layout

\begin_layout Standard
Для каждого нетерминала ставится в соответствие функция, рекурсивно вызывающая
 функции других нетерминалов.
\end_layout

\begin_layout Standard
Рисунок 1.
 Рассмотрим 
\emph on
преддективную
\emph default
 грамматику
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

e->+kle
\end_layout

\begin_layout Plain Layout

k->27d3
\end_layout

\begin_layout Plain Layout

l->-k|*d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// можем прям по ходу строить дерево
\end_layout

\begin_layout Plain Layout

void e(){ match('+'); k(); l(); e(); }
\end_layout

\begin_layout Plain Layout

void k(){ match('27');d(); match('3'); }
\end_layout

\begin_layout Plain Layout

void l(){ switch(next_char)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

		case '-': match('-');k();break;
\end_layout

\begin_layout Plain Layout

		case '*': match('*');d();break;
\end_layout

\begin_layout Plain Layout

		default: ERROR;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Алгоритм нисходящего разбора
\end_layout

\begin_layout Enumerate
Делаем стартовый символ (
\family typewriter
e
\family default
) корнем дерева.
 Задача --- для заданной строки, имея грамматику, построить дерево разбора.
\end_layout

\begin_layout Enumerate
Вызываем рекурсивную процедуру для стартового символа и добавляем в дерево
 соответствующие внутренним вызовам под узлы.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Однако, не всегда так можно сделать.
 Если продукция грамматики, например, такая:
\begin_inset Newline newline
\end_inset


\family typewriter
e->e+k
\begin_inset Newline newline
\end_inset

h->k*l
\end_layout

\begin_layout Standard
То тут всё очень плохо, т.к.
 будет следующая ситуация:
\end_layout

\begin_layout Standard

\family typewriter
void e() {e(); match('+'); k();}.

\family default
 
\end_layout

\begin_layout Standard
Упс, StackOverflow.
 Проблема грамматики в леворекурсивности.
 Необходмо просто преобразовтаь.
\end_layout

\begin_layout Description
Преддективные
\begin_inset space ~
\end_inset

парсеры --- парсеры, для которых необходимо чтобы по первому токену каждого
 правила грамматики можно было бы определить какую продукцию использовать.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*
Устранение левой рекурсивности
\end_layout

\begin_layout Standard
Рассмотрим 
\family typewriter
A->Aa|b, 
\family default
где 
\family typewriter
a
\family default
 --- некоторая строка из нетерминалов и терминалов, 
\family typewriter
b
\family default
 --- терминал.
 Явная леворекурсивная грамматика.
 
\family typewriter
A
\family default
 явно зависит от 
\family typewriter
A
\family default
.
 Все строки, которые принимает данная грамматика:
\end_layout

\begin_layout Standard

\family typewriter
b
\end_layout

\begin_layout Standard

\family typewriter
ba
\end_layout

\begin_layout Standard

\family typewriter
baa
\end_layout

\begin_layout Standard

\family typewriter
ba...a
\family default
 (
\family typewriter
n
\family default
-раз в общем случае.)
\end_layout

\begin_layout Standard
Преобразуем...
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

A->bB
\end_layout

\begin_layout Plain Layout

B->aB|E(empty)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Получили праворекурсивную грамматику.
 Проделаем тоже самое для грамматики 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# неплохая такая грамматика
\end_layout

\begin_layout Plain Layout

e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

t->t*k|t/k|k
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\begin_layout Plain Layout

*** Используем правило ***
\end_layout

\begin_layout Plain Layout

A->Aa|b 
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

A-> bB
\end_layout

\begin_layout Plain Layout

B->aB|E
\end_layout

\begin_layout Plain Layout

*** получаем ***
\end_layout

\begin_layout Plain Layout

> e->e+t|t
\end_layout

\begin_layout Plain Layout

e->tB
\end_layout

\begin_layout Plain Layout

B->+tB|E
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Усложним ка правило преобразования:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

A->Aa1|Aa2|b
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

A->bB
\end_layout

\begin_layout Plain Layout

B->a1B|a2B|E
\end_layout

\end_inset


\end_layout

\begin_layout Standard
И используя его, разберём всю первую строку:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

> e->e+t|e-t|t
\end_layout

\begin_layout Plain Layout

~ A->Aa1|Aa2|B
\end_layout

\begin_layout Plain Layout

=>
\end_layout

\begin_layout Plain Layout

e->tB
\end_layout

\begin_layout Plain Layout

B->+tB|-tB|E
\end_layout

\begin_layout Plain Layout

t->kC
\end_layout

\begin_layout Plain Layout

C->*kC|/kC|E
\end_layout

\begin_layout Plain Layout

k->(e)|d
\end_layout

\begin_layout Plain Layout

d->0|...|9
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Эквивалентная 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Боле-мене-адекватная"

\end_inset

 грамматика, но без левой рекурсивности
\begin_inset CommandInset label
LatexCommand label
name "fig:Эквивалентная--грамматика,"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Проверим на примере разбора
\family typewriter
 (2+3)*5
\family default
 , что на каждом шаге мы знаем, по какому правилу мы следуем.
 Результат представлен на рисунке 2.
 Написав функции по заданному принципу, мы можем построить парсер.
 
\end_layout

\begin_layout Subsubsection*

\series bold
Задание
\series default
: 
\end_layout

\begin_layout Enumerate
написать консольную программку, которая на основе грамматики (в которую
 добавить унарные + и - ) будет преобразовывать: принимает инфиксную строку
 ( 
\family typewriter
(2+3)*4 --> + 2 3 * 4
\family default
) преобразует в преобразует префиксную форму (польская нотация).
 
\end_layout

\begin_layout Enumerate
программку, которая вычисляет эти значения (из польской нотации).
\end_layout

\begin_layout Enumerate
Расширить грамматику 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Эквивалентная--грамматика,"

\end_inset

, для использования целых чисел (23 038 7357) и чисел с плавающей точкой
 (
\family typewriter
.23 3.
 3е15 3e+13 3e-13 3.7e10
\family default
) на бумаге.
 Кто хочет, может их и реализовать в прогах 1-2.
 Более интересный вариант задания.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Как мы помним, задача лексического анализатора --- разбиение исходной строки
 символов на токены.
 Дополнительно он может удалять некие ненужные конструкции.
 ЛА может использовать опережающее чтение.
 В идеале правила выделение не должны пересекаться (чтобы нельзя было интерпрети
ровать одну строку как цифру и как число).
 Чем проще правила для лексера, тем он эффективнее.
\end_layout

\begin_layout Standard
Как записываются токены, нам уже показывали:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# токены | # таблица символов
\end_layout

\begin_layout Plain Layout

---------|------------------
\end_layout

\begin_layout Plain Layout

<str,1>  |>1..."Вася"
\end_layout

\begin_layout Plain Layout

<num,2>  |>2...float 2.37
\end_layout

\end_inset


\end_layout

\begin_layout Standard
на вход парсеру подаются токены.
\end_layout

\begin_layout Section
Лексический анализ
\end_layout

\begin_layout Description
Лексический
\begin_inset space ~
\end_inset

анализ --- процесс преобразования входной строки символов в последовательность
 токенов.
 
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Очевидно, не может/не должно быть, что несколько токенов соответствуют одним
 и тем же символам (нахлёст).
 У каждого токена свой тип.
 Если типа нет, то мы его не учитываем.
 
\end_layout

\begin_layout Standard

\emph on
См.
 рисунок 3 (фото).
\end_layout

\begin_layout Standard
Лексический анализатор, при необходимости, обрабатывает токены, по мере
 того как синтаксический анализатор просит у него.
 
\end_layout

\begin_layout Standard

\emph on
См.
 рисунок 4.
\end_layout

\begin_layout Standard
Можно, но не обязательно, разделить лексический анализатор на 2 части.
 Первая отсекает всё ненужное, а вторая получает непосредственно токены.
\end_layout

\begin_layout Description
Токен --- пара, состоящая из типа и необязательного параметра, ссылающегося
 на таблицу символов 
\family typewriter
<тип, ссылка>
\family default
.
\end_layout

\begin_layout Description
Шаблон
\begin_inset space ~
\end_inset

токена --- вид, который может принимать строки, соответствующие данному
 токену.
\end_layout

\begin_layout Description
Лексема --- часть строки символов, соответствующая шаблону токенов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Таким образом, лексический анализатор разбивает исходную строку в соответствии
 шаблону на лексемы, а т.к.
 каждый шаблону соответствует токену с определённым типом, то затем мы из
 лексемы создаём определённый токен.
\end_layout

\begin_layout Standard
Обычно во многих языках присутствуют токены следующих видов:
\end_layout

\begin_layout Enumerate
токены для каждого ключевого слова
\end_layout

\begin_layout Enumerate
токены для операторов
\end_layout

\begin_layout Enumerate
токены для идентификаторов 
\end_layout

\begin_layout Enumerate
токены для констант и литералов
\end_layout

\begin_layout Enumerate
токены для символов пунктуации
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Есть класс ошибок, которые называются 
\emph on
лексическими ошибками
\emph default
.
 Возникают они при преобразовании строки символов в токен.
 
\begin_inset Newline newline
\end_inset

Например: 
\family typewriter
3name = 15,4;
\end_layout

\begin_layout Standard
Л.А.
 старается выделить максимальную последовательность, соответствующую шаблону(?)/
лексеме/идентификатору.
 Это 
\family typewriter
3name.

\family default
 Но что это --- непонятно ---> поэтому ошибка.
 Далее: 3 токена: 
\family typewriter
15 , 
\family default
и
\family typewriter
 4 
\family default
.
 Ошибка (т.к.
 запятая), но не лексическая.
\end_layout

\begin_layout Standard
При возникновении таких ошибок, многие лексические анализаторы стараются
 устранить её, чтобы восстановить поток символов
\begin_inset space ~
\end_inset

(чтобы компилятор старался показать как можно больше ошибок за один проход).
\end_layout

\begin_layout Standard
Подходы устранения ошибок:
\end_layout

\begin_layout Enumerate
удаление символа;
\end_layout

\begin_layout Enumerate
добавление символа;
\end_layout

\begin_layout Enumerate
перестановка двух символов;
\end_layout

\begin_layout Enumerate
изменение символа.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Так же, можно не считывать файл целиком, а использовать двойную буферизацию.
 В первый считывают ...
 Необходимо правильно выбрать размер буфера, чтобы макс.
 идентификатор не был больше длинны буфера.
 В конце буфера можно ставить уникальный для языка символ, например 
\family typewriter
EOF
\family default
, чтобы переходить от одного буфера к другому.
\end_layout

\begin_layout Subsection
Языки, строки
\end_layout

\begin_layout Description
Алфавит --- конечное множество символов.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\family typewriter
R = {a...z}
\end_layout

\begin_layout Standard

\family typewriter
Reg = {a...z,+,(,)}
\end_layout

\begin_layout Standard

\family typewriter
Rbin = {0,1}
\end_layout

\begin_layout Standard
По сути, это множество всех символов, которые могут присутствовать в файле.
\end_layout

\begin_layout Description
Строка
\begin_inset space ~
\end_inset

над
\begin_inset space ~
\end_inset

алфавитом --- конечная последовательность символов алфавита.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Например, строка 
\family typewriter
+a(*315
\family default
 --- строка над алфавитом регулярных выражений (
\family typewriter
Reg
\family default
).
\end_layout

\begin_layout Standard

\family typewriter
s 
\family default
--- строка над алфавитом.
 
\end_layout

\begin_layout Standard

\family typewriter
|s|
\family default
 --- длина строки.
 
\end_layout

\begin_layout Standard

\family typewriter
E|
\begin_inset Formula $\varepsilon$
\end_inset


\family default
 --- пустая строка.
\end_layout

\begin_layout Description
Язык --- некоторое счётное
\begin_inset space ~
\end_inset

(мб и не конечное) множество строк над алфавитом.
\end_layout

\begin_layout Description
Под
\begin_inset space ~
\end_inset

конкатенацией
\begin_inset space ~
\end_inset

строк
\begin_inset space ~
\end_inset


\family typewriter
s1
\family default

\begin_inset space ~
\end_inset

и
\begin_inset space ~
\end_inset


\family typewriter
s2
\family default
 будем понимать первую строку приписанную к ней справа вторую, т.е.
 
\family typewriter
s1s2.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Очевидно, получаются следующие правила:
\end_layout

\begin_layout Standard

\family typewriter
sE=Es=s
\end_layout

\begin_layout Standard
\begin_inset Formula $s^{0}=\varepsilon,$
\end_inset

 
\begin_inset Formula $s^{0}=s,s^{2}=ss,...,s^{n}=s^{n-1}s$
\end_inset

 (степень)
\end_layout

\begin_layout Subsubsection
Операции над языками
\end_layout

\begin_layout Standard
Пусть есть языки 
\begin_inset Formula $L_{1}$
\end_inset

 и 
\begin_inset Formula $L_{2}$
\end_inset

.
 
\end_layout

\begin_layout Standard

\emph on
Объединением
\emph default
 этих языков есть язык 
\begin_inset Formula $L=L_{1}\cup L_{2}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Конкатенацией
\emph default
 --- 
\begin_inset Formula $L=\{s_{1}s_{2}\},$
\end_inset

 
\begin_inset Formula $s_{1}\in L_{1},s_{2}\in L_{2}$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Замыкание Клини
\emph default
 
\begin_inset Formula $L_{1}$
\end_inset

 --- 
\end_layout

\begin_layout Standard

\emph on
Положительное замыкание
\emph default
 
\begin_inset Formula $L_{1}$
\end_inset

 ---
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsubsection
Регулярные выражения
\end_layout

\begin_layout Standard
Шаблоны токенов очень удобно задавать регулярными выражениями.
\end_layout

\begin_layout Standard
Пусть есть регулярное выражение 
\family typewriter
r
\family default
, над алфавитом 
\family typewriter
А.

\family default
 Тогда применив рег.
\begin_inset space ~
\end_inset

выр.
 к языку, можем получить некий язык 
\begin_inset Formula $L(r)$
\end_inset

, над алфавитом 
\family typewriter
А
\family default
.
 
\end_layout

\begin_layout Standard
Введём базис:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\varepsilon$
\end_inset

 --- рег.выражение ---> 
\begin_inset Formula $L(\varepsilon)=\{\varepsilon\}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall a\in A$
\end_inset

 --- рег.
\begin_inset space ~
\end_inset

выражение ---> 
\begin_inset Formula $L(a)=\{a\}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Subsubsection*

\series bold
Индукция
\end_layout

\begin_layout Standard
Если 
\begin_inset Formula $r_{1}$
\end_inset

 и 
\begin_inset Formula $r_{2}$
\end_inset

 --- рег.выражения, и 
\begin_inset Formula $L(r_{1}),L(r_{2})$
\end_inset

, то
\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{1}|r_{2}$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $L(r_{1})\cup L(r_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(r_{1})(r_{2})$
\end_inset

 --- рег.выражения, 
\begin_inset Formula $L(r_{1})L(r_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{1}^{*}$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $(L(r_{1}))^{*}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $(r_{1})$
\end_inset

 --- рег.выражение, 
\begin_inset Formula $L(r_{1})$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Попробуем теперь 
\family typewriter
[abc][def](abc)
\begin_inset Formula $^{*}$
\end_inset


\family default
 записать в наших обозначениях.
 Выйдет нечто вроде: 
\family typewriter
(((a|b)|c))(((d|e)|e))(((1)(2)(3))
\begin_inset Formula $^{*}$
\end_inset

.
 
\family default
Очевидно, что какая-то жесть\SpecialChar \ldots{}
 короче явно не хватает правила приоритетов.
\end_layout

\begin_layout Subsubsection
Правила приоритетов
\end_layout

\begin_layout Standard
По уменьшению приоритета:
\end_layout

\begin_layout Enumerate

\family typewriter
*
\family default
 --- левоассоциативный
\end_layout

\begin_layout Enumerate
конкатенация --- левоассоцитивный
\end_layout

\begin_layout Enumerate

\family typewriter
|
\family default
 --- левоассоциативен
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Тогда уже можно переписать то выражение как 
\family typewriter
(a|b|c)(d|e|f)(123)
\begin_inset Formula $^{*}$
\end_inset


\family default
.
\end_layout

\begin_layout Subsubsection*

\series bold
Примеры
\end_layout

\begin_layout Standard

\family typewriter
(a|b)* = {E, a, b,
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}$
\end_inset


\family default
 --- любая строка из символов
\family typewriter
 a 
\family default
и
\family typewriter
 b
\end_layout

\begin_layout Standard

\family typewriter
a* = {E, a, aa, ...}
\end_layout

\begin_layout Standard

\family typewriter
ab*(c|d)* = {a, ab...b
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}\in\{c,d\}$
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
(ab*)* = {E, a, a
\begin_inset Formula $\lambda_{i}$
\end_inset

}, 
\begin_inset Formula $\lambda_{i}$
\end_inset


\family default
 --- любая выборка 
\family typewriter
a,b
\end_layout

\begin_layout Standard
((ab*)*) = ...
\end_layout

\begin_layout Standard
в общем виде, 
\family typewriter
r* = (r*)*
\family default
, т.к.
 оператор Клини идемпотентен.
\end_layout

\begin_layout Subsubsection
Законы преобразования регулярных выражений.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Formula $(r_{1}|r_{2})=(r_{2}|r_{1})$
\end_inset

 
\family default
// коммутативность объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}|r_{2})|r_{3}=r_{1}|(r_{2}|r_{3})$
\end_inset

 // ассоциативность объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}r_{2})r_{3}=r_{1}(r_{2}r3)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $r_{1}(r_{2}|r_{3})=r_{1}r_{2}|r_{1}r_{3}$
\end_inset

 // левая дистрибутивность конкатенации относительно объединения
\end_layout

\begin_layout Standard
\begin_inset Formula $(r_{1}|r_{2})r_{3}=r_{1}r3|r_{2}r_{3}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $r*=(r|E)*$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $rE=Er=r$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(r*)*=r*$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Лекция 5 // -2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "dragon-book"

\end_inset

А.
 Ахо., Ульман 
\begin_inset Quotes fld
\end_inset

Компиляторы(книга дракона)
\begin_inset Quotes frd
\end_inset

 // хватит сполна
\end_layout

\end_body
\end_document
